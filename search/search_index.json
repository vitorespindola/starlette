{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u2728 The little ASGI framework that shines. \u2728 Introduction Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. It is production-ready, and gives you the following: Seriously impressive performance. WebSocket support. GraphQL support. In-process background tasks. Startup and shutdown events. Test client built on requests . CORS, GZip, Static Files, Streaming responses. Session and Cookie support. 100% test coverage. 100% type annotated codebase. Zero hard dependencies. Requirements Python 3.6+ Installation $ pip3 install starlette You'll also want to install an ASGI server, such as uvicorn , daphne , or hypercorn . $ pip3 install uvicorn Example from starlette.applications import Starlette from starlette.responses import JSONResponse import uvicorn app = Starlette () @app.route ( '/' ) async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) if __name__ == '__main__' : uvicorn . run ( app , host = '0.0.0.0' , port = 8000 ) For a more complete example, see here . Dependencies Starlette does not have any hard dependencies, but the following are optional: requests - Required if you want to use the TestClient . aiofiles - Required if you want to use FileResponse or StaticFiles . jinja2 - Required if you want to use the default template configuration. python-multipart - Required if you want to support form parsing, with request.form() . itsdangerous - Required for SessionMiddleware support. sqlalchemy - Required for DatabaseMiddleware support. pyyaml - Required for SchemaGenerator support. graphene - Required for GraphQLApp support. ujson - Required if you want to use UJSONResponse . You can install all of these with pip3 install starlette[full] . Framework or Toolkit Starlette is designed to be used either as a complete framework, or as an ASGI toolkit. You can use any of its components independently. from starlette.responses import PlainTextResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send ) Run the App application in example.py : $ uvicorn example:App INFO: Started server process [ 11509 ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) Modularity The modularity that Starlette is designed on promotes building re-usable components that can be shared between any ASGI framework. This should enable an ecosystem of shared middleware and mountable applications. The clean API separation also means it's easier to understand each component in isolation. Performance Independent TechEmpower benchmarks show Starlette applications running under Uvicorn as one of the fastest Python frameworks available . (*) For high throughput loads you should: Make sure to install ujson and use UJSONResponse . Run using Gunicorn using the uvicorn worker class. Use one or two workers per-CPU core. (You might need to experiment with this.) Disable access logging. For example: gunicorn -w 4 -k uvicorn.workers.UvicornWorker --log-level warning example:app Several of the ASGI servers also have pure Python implementations available, so you can also run under PyPy if your application code has parts that are CPU constrained. Either programatically: uvicorn . run ( ... , http = 'h11' , loop = 'asyncio' ) Or using Gunicorn: gunicorn -k uvicorn.workers.UvicornH11Worker ... \u2014 \u2b50\ufe0f \u2014 Starlette is BSD licensed code. Designed & built in Brighton, England.","title":"Introduction"},{"location":"#introduction","text":"Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. It is production-ready, and gives you the following: Seriously impressive performance. WebSocket support. GraphQL support. In-process background tasks. Startup and shutdown events. Test client built on requests . CORS, GZip, Static Files, Streaming responses. Session and Cookie support. 100% test coverage. 100% type annotated codebase. Zero hard dependencies.","title":"Introduction"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"$ pip3 install starlette You'll also want to install an ASGI server, such as uvicorn , daphne , or hypercorn . $ pip3 install uvicorn","title":"Installation"},{"location":"#example","text":"from starlette.applications import Starlette from starlette.responses import JSONResponse import uvicorn app = Starlette () @app.route ( '/' ) async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) if __name__ == '__main__' : uvicorn . run ( app , host = '0.0.0.0' , port = 8000 ) For a more complete example, see here .","title":"Example"},{"location":"#dependencies","text":"Starlette does not have any hard dependencies, but the following are optional: requests - Required if you want to use the TestClient . aiofiles - Required if you want to use FileResponse or StaticFiles . jinja2 - Required if you want to use the default template configuration. python-multipart - Required if you want to support form parsing, with request.form() . itsdangerous - Required for SessionMiddleware support. sqlalchemy - Required for DatabaseMiddleware support. pyyaml - Required for SchemaGenerator support. graphene - Required for GraphQLApp support. ujson - Required if you want to use UJSONResponse . You can install all of these with pip3 install starlette[full] .","title":"Dependencies"},{"location":"#framework-or-toolkit","text":"Starlette is designed to be used either as a complete framework, or as an ASGI toolkit. You can use any of its components independently. from starlette.responses import PlainTextResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send ) Run the App application in example.py : $ uvicorn example:App INFO: Started server process [ 11509 ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit )","title":"Framework or Toolkit"},{"location":"#modularity","text":"The modularity that Starlette is designed on promotes building re-usable components that can be shared between any ASGI framework. This should enable an ecosystem of shared middleware and mountable applications. The clean API separation also means it's easier to understand each component in isolation.","title":"Modularity"},{"location":"#performance","text":"Independent TechEmpower benchmarks show Starlette applications running under Uvicorn as one of the fastest Python frameworks available . (*) For high throughput loads you should: Make sure to install ujson and use UJSONResponse . Run using Gunicorn using the uvicorn worker class. Use one or two workers per-CPU core. (You might need to experiment with this.) Disable access logging. For example: gunicorn -w 4 -k uvicorn.workers.UvicornWorker --log-level warning example:app Several of the ASGI servers also have pure Python implementations available, so you can also run under PyPy if your application code has parts that are CPU constrained. Either programatically: uvicorn . run ( ... , http = 'h11' , loop = 'asyncio' ) Or using Gunicorn: gunicorn -k uvicorn.workers.UvicornH11Worker ... \u2014 \u2b50\ufe0f \u2014 Starlette is BSD licensed code. Designed & built in Brighton, England.","title":"Performance"},{"location":"applications/","text":"Starlette includes an application class Starlette that nicely ties together all of its other functionality. from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.staticfiles import StaticFiles app = Starlette () app . debug = True app . mount ( '/static' , StaticFiles ( directory = \"static\" )) @app.route ( '/' ) def homepage ( request ): return PlainTextResponse ( 'Hello, world!' ) @app.route ( '/user/me' ) def user_me ( request ): username = \"John Doe\" return PlainTextResponse ( 'Hello, %s !' % username ) @app.route ( '/user/{username}' ) def user ( request ): username = request . path_params [ 'username' ] return PlainTextResponse ( 'Hello, %s !' % username ) @app.websocket_route ( '/ws' ) async def websocket_endpoint ( websocket ): await websocket . accept () await websocket . send_text ( 'Hello, websocket!' ) await websocket . close () @app.on_event ( 'startup' ) def startup (): print ( 'Ready to go' ) Instantiating the application Starlette(debug=False) - Create a new Starlette application. Adding routes to the application You can use any of the following to add handled routes to the application: app.add_route(path, func, methods=[\"GET\"]) - Add an HTTP route. The function may be either a coroutine or a regular function, with a signature like func(request, **kwargs) -> response . app.add_websocket_route(path, func) - Add a websocket session route. The function must be a coroutine, with a signature like func(session, **kwargs) . @app.route(path) - Add an HTTP route, decorator style. @app.websocket_route(path) - Add a WebSocket route, decorator style. Adding event handlers to the application There are two ways to add event handlers: @app.on_event(event_type) - Add an event, decorator style app.add_event_handler(event_type, func) - Add an event through a function call. event_type must be specified as either 'startup' or 'shutdown' . Submounting other applications Submounting applications is a powerful way to include reusable ASGI applications. app.mount(prefix, app) - Include an ASGI app, mounted under the given path prefix Customizing exception handling You can use either of the following to catch and handle particular types of exceptions that occur within the application: app.add_exception_handler(exc_class_or_status_code, handler) - Add an error handler. The handler function may be either a coroutine or a regular function, with a signature like func(request, exc) -> response . @app.exception_handler(exc_class_or_status_code) - Add an error handler, decorator style. app.debug - Enable or disable error tracebacks in the browser.","title":"Applications"},{"location":"applications/#instantiating-the-application","text":"Starlette(debug=False) - Create a new Starlette application.","title":"Instantiating the application"},{"location":"applications/#adding-routes-to-the-application","text":"You can use any of the following to add handled routes to the application: app.add_route(path, func, methods=[\"GET\"]) - Add an HTTP route. The function may be either a coroutine or a regular function, with a signature like func(request, **kwargs) -> response . app.add_websocket_route(path, func) - Add a websocket session route. The function must be a coroutine, with a signature like func(session, **kwargs) . @app.route(path) - Add an HTTP route, decorator style. @app.websocket_route(path) - Add a WebSocket route, decorator style.","title":"Adding routes to the application"},{"location":"applications/#adding-event-handlers-to-the-application","text":"There are two ways to add event handlers: @app.on_event(event_type) - Add an event, decorator style app.add_event_handler(event_type, func) - Add an event through a function call. event_type must be specified as either 'startup' or 'shutdown' .","title":"Adding event handlers to the application"},{"location":"applications/#submounting-other-applications","text":"Submounting applications is a powerful way to include reusable ASGI applications. app.mount(prefix, app) - Include an ASGI app, mounted under the given path prefix","title":"Submounting other applications"},{"location":"applications/#customizing-exception-handling","text":"You can use either of the following to catch and handle particular types of exceptions that occur within the application: app.add_exception_handler(exc_class_or_status_code, handler) - Add an error handler. The handler function may be either a coroutine or a regular function, with a signature like func(request, exc) -> response . @app.exception_handler(exc_class_or_status_code) - Add an error handler, decorator style. app.debug - Enable or disable error tracebacks in the browser.","title":"Customizing exception handling"},{"location":"authentication/","text":"Starlette offers a simple but powerful interface for handling authentication and permissions. Once you've installed AuthenticationMiddleware with an appropriate authentication backend the request.user and request.auth interfaces will be available in your endpoints. from starlette.authentication import ( AuthenticationBackend , AuthenticationError , SimpleUser , UnauthenticatedUser , AuthCredentials ) from starlette.middleware.authentication import AuthenticationMiddleware from starlette.responses import PlainTextResponse import base64 import binascii class BasicAuthBackend ( AuthenticationBackend ): async def authenticate ( self , request ): if \"Authorization\" not in request . headers : return auth = request . headers [ \"Authorization\" ] try : scheme , credentials = auth . split () if scheme . lower () != 'basic' : return decoded = base64 . b64decode ( credentials ) . decode ( \"ascii\" ) except ( ValueError , UnicodeDecodeError , binascii . Error ) as exc : raise AuthenticationError ( 'Invalid basic auth credentials' ) username , _ , password = decoded . partition ( \":\" ) # TODO: You'd want to verify the username and password here, # possibly by installing `DatabaseMiddleware` # and retrieving user information from `request.database`. return AuthCredentials ([ \"authenticated\" ]), SimpleUser ( username ) app = Starlette () app . add_middleware ( AuthenticationMiddleware , backend = BasicAuthBackend ()) @app.route ( '/' ) async def homepage ( request ): if request . user . is_authenticated : return PlainTextResponse ( 'hello, ' + request . user . display_name ) return PlainTextResponse ( 'hello, you' ) Users Once AuthenticationMiddleware is installed the request.user interface will be available to endpoints or other middleware. This interface should subclass BaseUser , which provides two properties, as well as whatever other information your user model includes. .is_authenticated .display_name Starlette provides two built-in user implementations: UnauthenticatedUser() , and SimpleUser(username) . AuthCredentials It is important that authentication credentials are treated as separate concept from users. An authentication scheme should be able to restrict or grant particular privileges independently of the user identity. The AuthCredentials class provides the basic interface that request.auth exposes: .scopes Permissions Permissions are implemented as an endpoint decorator, that enforces that the incoming request includes the required authentication scopes. from starlette.authentication import requires @app.route ( '/dashboard' ) @requires ( 'authenticated' ) async def dashboard ( request ): ... You can include either one or multiple required scopes: from starlette.authentication import requires @app.route ( '/dashboard' ) @requires ([ 'authenticated' , 'admin' ]) async def dashboard ( request ): ... By default 403 responses will be returned when permissions are not granted. In some cases you might want to customize this, for example to hide information about the URL layout from unauthenticated users. from starlette.authentication import requires @app.route ( '/dashboard' ) @requires ([ 'authenticated' , 'admin' ], status_code = 404 ) async def dashboard ( request ): ... Alternatively you might want to redirect unauthenticated users to a different page. from starlette.authentication import requires @app.route ( '/homepage' ) async def homepage ( request ): ... @app.route ( '/dashboard' ) @requires ( 'authenticated' , redirect = 'homepage' ) async def dashboard ( request ): ... For class-based endpoints, you should wrap the decorator around a method on the class. @app.route ( \"/dashboard\" ) class Dashboard ( HTTPEndpoint ): @requires ( \"authenticated\" ) async def get ( self , request ): ... Custom authentication error responses You can customise the error response sent when a AuthenticationError is raised by an auth backend: def on_auth_error ( request : Request , exc : Exception ): return JSONResponse ({ \"error\" : str ( exc )}, status_code = 401 ) app . add_middleware ( AuthenticationMiddleware , backend = BasicAuthBackend (), on_error = on_auth_error )","title":"Authentication"},{"location":"authentication/#users","text":"Once AuthenticationMiddleware is installed the request.user interface will be available to endpoints or other middleware. This interface should subclass BaseUser , which provides two properties, as well as whatever other information your user model includes. .is_authenticated .display_name Starlette provides two built-in user implementations: UnauthenticatedUser() , and SimpleUser(username) .","title":"Users"},{"location":"authentication/#authcredentials","text":"It is important that authentication credentials are treated as separate concept from users. An authentication scheme should be able to restrict or grant particular privileges independently of the user identity. The AuthCredentials class provides the basic interface that request.auth exposes: .scopes","title":"AuthCredentials"},{"location":"authentication/#permissions","text":"Permissions are implemented as an endpoint decorator, that enforces that the incoming request includes the required authentication scopes. from starlette.authentication import requires @app.route ( '/dashboard' ) @requires ( 'authenticated' ) async def dashboard ( request ): ... You can include either one or multiple required scopes: from starlette.authentication import requires @app.route ( '/dashboard' ) @requires ([ 'authenticated' , 'admin' ]) async def dashboard ( request ): ... By default 403 responses will be returned when permissions are not granted. In some cases you might want to customize this, for example to hide information about the URL layout from unauthenticated users. from starlette.authentication import requires @app.route ( '/dashboard' ) @requires ([ 'authenticated' , 'admin' ], status_code = 404 ) async def dashboard ( request ): ... Alternatively you might want to redirect unauthenticated users to a different page. from starlette.authentication import requires @app.route ( '/homepage' ) async def homepage ( request ): ... @app.route ( '/dashboard' ) @requires ( 'authenticated' , redirect = 'homepage' ) async def dashboard ( request ): ... For class-based endpoints, you should wrap the decorator around a method on the class. @app.route ( \"/dashboard\" ) class Dashboard ( HTTPEndpoint ): @requires ( \"authenticated\" ) async def get ( self , request ): ...","title":"Permissions"},{"location":"authentication/#custom-authentication-error-responses","text":"You can customise the error response sent when a AuthenticationError is raised by an auth backend: def on_auth_error ( request : Request , exc : Exception ): return JSONResponse ({ \"error\" : str ( exc )}, status_code = 401 ) app . add_middleware ( AuthenticationMiddleware , backend = BasicAuthBackend (), on_error = on_auth_error )","title":"Custom authentication error responses"},{"location":"background/","text":"Starlette includes a BackgroundTask class for in-process background tasks. A background task should be attached to a response, and will run only once the response has been sent. Background Task Used to add a single background task to a response. Signature: BackgroundTask(func, *args, **kwargs) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.background import BackgroundTask app = Starlette () @app.route ( '/user/signup' , methods = [ 'POST' ]) async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] task = BackgroundTask ( send_welcome_email , to_address = email ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = task ) async def send_welcome_email ( to_address ): ... BackgroundTasks Used to add multiple background tasks to a response. Signature: BackgroundTasks(tasks=[]) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.background import BackgroundTasks app = Starlette () @app.route ( '/user/signup' , methods = [ 'POST' ]) async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] tasks = BackgroundTasks () tasks . add_task ( send_welcome_email , to_address = email ) tasks . add_task ( send_admin_notification , username = username ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = tasks ) async def send_welcome_email ( to_address ): ... async def send_admin_notification ( username ): ...","title":"Background Tasks"},{"location":"background/#background-task","text":"Used to add a single background task to a response. Signature: BackgroundTask(func, *args, **kwargs) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.background import BackgroundTask app = Starlette () @app.route ( '/user/signup' , methods = [ 'POST' ]) async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] task = BackgroundTask ( send_welcome_email , to_address = email ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = task ) async def send_welcome_email ( to_address ): ...","title":"Background Task"},{"location":"background/#backgroundtasks","text":"Used to add multiple background tasks to a response. Signature: BackgroundTasks(tasks=[]) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.background import BackgroundTasks app = Starlette () @app.route ( '/user/signup' , methods = [ 'POST' ]) async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] tasks = BackgroundTasks () tasks . add_task ( send_welcome_email , to_address = email ) tasks . add_task ( send_admin_notification , username = username ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = tasks ) async def send_welcome_email ( to_address ): ... async def send_admin_notification ( username ): ...","title":"BackgroundTasks"},{"location":"config/","text":"Starlette encourages a strict separation of configuration from code, following the twelve-factor pattern . Configuration should be stored in environment variables, or in a \".env\" file that is not committed to source control. app.py : from starlette.applications import Starlette from starlette.config import Config from starlette.datastructures import CommaSeparatedStrings , DatabaseURL , Secret # Config will be read from environment variables and/or \".env\" files. config = Config ( \".env\" ) DEBUG = config ( 'DEBUG' , cast = bool , default = False ) DATABASE_URL = config ( 'DATABASE_URL' , cast = DatabaseURL ) SECRET_KEY = config ( 'SECRET_KEY' , cast = Secret ) ALLOWED_HOSTS = config ( 'ALLOWED_HOSTS' , cast = CommaSeparatedStrings ) app = Starlette () app . debug = DEBUG ... .env : # Don't commit this to source control. # Eg. Include \".env\" in your `.gitignore` file. DEBUG = True DATABASE_URL = postgresql://localhost/myproject SECRET_KEY = 43n080musdfjt54t-09sdgr ALLOWED_HOSTS = \"127.0.0.1\" , \"localhost\" Configuration precedence The order in which configuration values are read is: From an environment variable. From the \".env\" file. The default value given in config . If none of those match, then config(...) will raise an error. Secrets For sensitive keys, the Secret class is useful, since it helps minimize occasions where the value it holds could leak out into tracebacks or other code introspection. To get the value of a Secret instance, you must explicitly cast it to a string. You should only do this at the point at which the value is used. >>> from myproject import settings >>> settings . SECRET_KEY Secret ( '**********' ) >>> str ( settings . SECRET_KEY ) '98n349$%8b8-7yjn0n8y93T$23r' Similarly, the URL and DatabaseURL class will hide any password component in their representations. >>> from myproject import settings >>> settings . DATABASE_URL DatabaseURL ( 'postgresql://admin:**********@192.168.0.8/my-application' ) >>> str ( settings . DATABASE_URL ) 'postgresql://admin:Fkjh348htGee4t3@192.168.0.8/my-application' CommaSeparatedStrings For holding multiple inside a single config key, the CommaSeparatedStrings type is useful. >>> from myproject import settings >>> print ( settings . ALLOWED_HOSTS ) CommaSeparatedStrings ([ '127.0.0.1' , 'localhost' ]) >>> print ( list ( settings . ALLOWED_HOSTS )) [ '127.0.0.1' , 'localhost' ] >>> print ( len ( settings . ALLOWED_HOSTS [ 0 ])) 2 >>> print ( settings . ALLOWED_HOSTS [ 0 ]) '127.0.0.1' Reading or modifying the environment In some cases you might want to read or modify the environment variables programmatically. This is particularly useful in testing, where you may want to override particular keys in the environment. Rather than reading or writing from os.environ , you should use Starlette's environ instance. This instance is a mapping onto the standard os.environ that additionally protects you by raising an error if any environment variable is set after the point that it has already been read by the configuration. If you're using pytest , then you can setup any initial environment in tests/conftest.py . tests/conftest.py : from starlette.config import environ environ [ 'TESTING' ] = 'TRUE' A full example Structuring large applications can be complex. You need proper separation of configuration and code, database isolation during tests, separate test and production databases, etc... Here we'll take a look at a complete example, that demonstrates how we can start to structure an application. First, let's keep our settings, our database table definitions, and our application logic separated: myproject/settings.py : from starlette.config import Config from starlette.datastructures import DatabaseURL , Secret config = Config ( \".env\" ) DEBUG = config ( 'DEBUG' , cast = bool , default = False ) TESTING = config ( 'TESTING' , cast = bool , default = False ) SECRET_KEY = config ( 'SECRET_KEY' , cast = Secret ) DATABASE_URL = config ( 'DATABASE_URL' , cast = DatabaseURL ) if TESTING : DATABASE_URL = DATABASE_URL . replace ( database = 'test_' + DATABASE_URL . database ) myproject/tables.py : import sqlalchemy # Database table definitions. metadata = sqlalchemy . MetaData () organisations = sqlalchemy . Table ( ... ) myproject/app.py from starlette.applications import Starlette from starlette.middleware.database import DatabaseMiddleware from starlette.middleware.session import SessionMiddleware from myproject import settings app = Starlette () app . debug = settings . DEBUG app . add_middleware ( SessionMiddleware , secret_key = settings . SECRET_KEY , ) app . add_middleware ( DatabaseMiddleware , database_url = settings . DATABASE_URL , rollback_on_shutdown = settings . TESTING ) @app.route ( '/' , methods = [ 'GET' ]) async def homepage ( request ): ... Now let's deal with our test configuration. We'd like to create a new test database every time the test suite runs, and drop it once the tests complete. We'd also like to ensure tests/conftest.py : from starlette.config import environ from starlette.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy_utils import database_exists , create_database # This line would raise an error if we use it after 'settings' has been imported. environ [ 'TESTING' ] = 'TRUE' from myproject import settings from myproject.app import app from myproject.tables import metadata @pytest.fixture ( autouse = True , scope = \"session\" ) def setup_test_database (): \"\"\" Create a clean test database every time the tests are run. \"\"\" url = str ( settings . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. metadata . create_all ( engine ) # Create the tables. yield # Run the tests. drop_database ( url ) # Drop the test database. @pytest.fixture () def client (): \"\"\" Make a 'client' fixture available to test cases. \"\"\" # Our fixture is created within a context manager. This ensures that # application startup and shutdown run for every test case. # # Because we've configured the DatabaseMiddleware with `rollback_on_shutdown` # we'll get a complete rollback to the initial state after each test case runs. with TestClient ( app ) as test_client : yield test_client","title":"Configuration"},{"location":"config/#configuration-precedence","text":"The order in which configuration values are read is: From an environment variable. From the \".env\" file. The default value given in config . If none of those match, then config(...) will raise an error.","title":"Configuration precedence"},{"location":"config/#secrets","text":"For sensitive keys, the Secret class is useful, since it helps minimize occasions where the value it holds could leak out into tracebacks or other code introspection. To get the value of a Secret instance, you must explicitly cast it to a string. You should only do this at the point at which the value is used. >>> from myproject import settings >>> settings . SECRET_KEY Secret ( '**********' ) >>> str ( settings . SECRET_KEY ) '98n349$%8b8-7yjn0n8y93T$23r' Similarly, the URL and DatabaseURL class will hide any password component in their representations. >>> from myproject import settings >>> settings . DATABASE_URL DatabaseURL ( 'postgresql://admin:**********@192.168.0.8/my-application' ) >>> str ( settings . DATABASE_URL ) 'postgresql://admin:Fkjh348htGee4t3@192.168.0.8/my-application'","title":"Secrets"},{"location":"config/#commaseparatedstrings","text":"For holding multiple inside a single config key, the CommaSeparatedStrings type is useful. >>> from myproject import settings >>> print ( settings . ALLOWED_HOSTS ) CommaSeparatedStrings ([ '127.0.0.1' , 'localhost' ]) >>> print ( list ( settings . ALLOWED_HOSTS )) [ '127.0.0.1' , 'localhost' ] >>> print ( len ( settings . ALLOWED_HOSTS [ 0 ])) 2 >>> print ( settings . ALLOWED_HOSTS [ 0 ]) '127.0.0.1'","title":"CommaSeparatedStrings"},{"location":"config/#reading-or-modifying-the-environment","text":"In some cases you might want to read or modify the environment variables programmatically. This is particularly useful in testing, where you may want to override particular keys in the environment. Rather than reading or writing from os.environ , you should use Starlette's environ instance. This instance is a mapping onto the standard os.environ that additionally protects you by raising an error if any environment variable is set after the point that it has already been read by the configuration. If you're using pytest , then you can setup any initial environment in tests/conftest.py . tests/conftest.py : from starlette.config import environ environ [ 'TESTING' ] = 'TRUE'","title":"Reading or modifying the environment"},{"location":"config/#a-full-example","text":"Structuring large applications can be complex. You need proper separation of configuration and code, database isolation during tests, separate test and production databases, etc... Here we'll take a look at a complete example, that demonstrates how we can start to structure an application. First, let's keep our settings, our database table definitions, and our application logic separated: myproject/settings.py : from starlette.config import Config from starlette.datastructures import DatabaseURL , Secret config = Config ( \".env\" ) DEBUG = config ( 'DEBUG' , cast = bool , default = False ) TESTING = config ( 'TESTING' , cast = bool , default = False ) SECRET_KEY = config ( 'SECRET_KEY' , cast = Secret ) DATABASE_URL = config ( 'DATABASE_URL' , cast = DatabaseURL ) if TESTING : DATABASE_URL = DATABASE_URL . replace ( database = 'test_' + DATABASE_URL . database ) myproject/tables.py : import sqlalchemy # Database table definitions. metadata = sqlalchemy . MetaData () organisations = sqlalchemy . Table ( ... ) myproject/app.py from starlette.applications import Starlette from starlette.middleware.database import DatabaseMiddleware from starlette.middleware.session import SessionMiddleware from myproject import settings app = Starlette () app . debug = settings . DEBUG app . add_middleware ( SessionMiddleware , secret_key = settings . SECRET_KEY , ) app . add_middleware ( DatabaseMiddleware , database_url = settings . DATABASE_URL , rollback_on_shutdown = settings . TESTING ) @app.route ( '/' , methods = [ 'GET' ]) async def homepage ( request ): ... Now let's deal with our test configuration. We'd like to create a new test database every time the test suite runs, and drop it once the tests complete. We'd also like to ensure tests/conftest.py : from starlette.config import environ from starlette.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy_utils import database_exists , create_database # This line would raise an error if we use it after 'settings' has been imported. environ [ 'TESTING' ] = 'TRUE' from myproject import settings from myproject.app import app from myproject.tables import metadata @pytest.fixture ( autouse = True , scope = \"session\" ) def setup_test_database (): \"\"\" Create a clean test database every time the tests are run. \"\"\" url = str ( settings . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. metadata . create_all ( engine ) # Create the tables. yield # Run the tests. drop_database ( url ) # Drop the test database. @pytest.fixture () def client (): \"\"\" Make a 'client' fixture available to test cases. \"\"\" # Our fixture is created within a context manager. This ensures that # application startup and shutdown run for every test case. # # Because we've configured the DatabaseMiddleware with `rollback_on_shutdown` # we'll get a complete rollback to the initial state after each test case runs. with TestClient ( app ) as test_client : yield test_client","title":"A full example"},{"location":"database/","text":"Starlette includes optional database support. There is currently only a driver for Postgres databases, but MySQL and SQLite support is planned. Enabling the built-in database support requires sqlalchemy , and an appropriate database driver. Currently this means asyncpg is a requirement. The database support is completely optional - you can either include the middleware or not, or you can build alternative kinds of backends instead. It does not include support for an ORM, but it does support using queries built using SQLAlchemy Core . Here's a complete example, that includes table definitions, installing the DatabaseMiddleware , and a couple of endpoints that interact with the database. import sqlalchemy from starlette.applications import Starlette from starlette.config import Config from starlette.middleware.database import DatabaseMiddleware from starlette.responses import JSONResponse # Configuration from environment variables or '.env' file. config = Config ( '.env' ) DATABASE_URL = config ( 'DATABASE_URL' ) # Database table definitions. metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) # Application setup. app = Starlette () app . add_middleware ( DatabaseMiddleware , database_url = DATABASE_URL ) # Endpoints. @app.route ( \"/notes\" , methods = [ \"GET\" ]) async def list_notes ( request ): query = notes . select () results = await request . database . fetchall ( query ) content = [ { \"text\" : result [ \"text\" ], \"completed\" : result [ \"completed\" ] } for result in results ] return JSONResponse ( content ) @app.route ( \"/notes\" , methods = [ \"POST\" ]) async def add_note ( request ): data = await request . json () query = notes . insert () . values ( text = data [ \"text\" ], completed = data [ \"completed\" ] ) await request . database . execute ( query ) return JSONResponse ({ \"text\" : data [ \"text\" ], \"completed\" : data [ \"completed\" ] }) Queries Queries may be made with as SQLAlchemy Core queries , or as raw SQL. The following are supported: request.database.fetchall(query) request.database.fetchone(query) request.database.fetchval(query) request.database.execute(query) Transactions Database transactions are available either as an endpoint decorator, as a context manager, or as a low-level API. Using a decorator on an endpoint: from starlette.databases import transaction @transaction async def populate_note ( request ): # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await request . database . execute ( query ) raise RuntimeError () Using a context manager: async def populate_note ( request ): async with request . database . transaction (): # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await request . database . execute ( query ) raise RuntimeError () Using the low-level API: async def populate_note ( request ): transaction = request . database . transaction () transaction . start () try : # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await request . database . execute ( query ) raise RuntimeError () except : transaction . rollback () raise else : transaction . commit () Test isolation There are a few things that we want to ensure when running tests against a service that uses a database. Our requirements should be: Use a separate database for testing. Create a new test database every time we run the tests. Ensure that the database state is isolated between each test case. Here's how we need to structure our application and tests in order to meet those requirements: from starlette.applications import Starlette from starlette.config import Config config = Config ( \".env\" ) TESTING = config ( 'TESTING' , cast = bool , default = False ) DATABASE_URL = config ( 'DATABASE_URL' , cast = DatabaseURL ) if TESTING : # Use a database name like \"test_myapplication\" for tests. DATABASE_URL = DATABASE_URL . replace ( database = 'test_' + DATABASE_URL . database ) # Use 'rollback_on_shutdown' during testing, to ensure we have app = Starlette () app . add_middleware ( DatabaseMiddleware , database_url = DATABASE_URL , rollback_on_shutdown = TESTING ) We still need to set TESTING during a test run, and setup the test database. Assuming we're using py.test , here's how our conftest.py might look: import pytest from starlette.config import environ from starlette.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy_utils import database_exists , create_database # This sets `os.environ`, but provides some additional protection. # If we placed it below the application import, it would raise an error # informing us that 'TESTING' had already been read from the environment. environ [ 'TESTING' ] = 'True' import app @pytest.fixture ( scope = \"session\" , autouse = True ) def create_test_database (): \"\"\" Create a clean database on every test case. For safety, we should abort if a database already exists. We use the `sqlalchemy_utils` package here for a few helpers in consistently creating and dropping the database. \"\"\" url = str ( app . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. metadata . create_all ( engine ) # Create the tables. yield # Run the tests. drop_database ( url ) # Drop the test database. @pytest.fixture () def client (): \"\"\" When using the 'client' fixture in test cases, we'll get full database rollbacks between test cases: def test_homepage(client): url = app.url_path_for('homepage') response = client.get(url) assert response.status_code == 200 \"\"\" with TestClient ( app ) as client : yield client Migrations You'll almost certainly need to be using database migrations in order to manage incremental changes to the database. For this we'd strongly recommend Alembic , which is written by the author of SQLAlchemy. $ pip install alembic $ pip install psycopg2-binary # Install an appropriate database driver. $ alembic init migrations Now, you'll want to set things up so that Alembic references the configured DATABASE_URL, and uses your table metadata. In alembic.ini remove the following line: sqlalchemy.url = driver://user:pass@localhost/dbname In migrations/env.py , you need to set the 'sqlalchemy.url' configuration key, and the target_metadata variable. You'll want something like this: # The Alembic Config object. config = context . config # Configure Alembic to use our DATABASE_URL and our table definitions... import app config . set_main_option ( 'sqlalchemy.url' , str ( app . DATABASE_URL )) target_metadata = app . metadata ... Running migrations during testing It is good practice to ensure that your test suite runs the database migrations every time it creates the test database. This will help catch any issues in your migration scripts, and will help ensure that the tests are running against a database that's in a consistent state with your live database. We can adjust the create_test_database fixture slightly: from alembic import command from alembic.config import Config ... @pytest.fixture ( scope = \"session\" , autouse = True ) def create_test_database (): url = str ( app . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. config = Config ( \"alembic.ini\" ) # Run the migrations. command . upgrade ( config , \"head\" ) yield # Run the tests. drop_database ( url ) # Drop the test database.","title":"Database"},{"location":"database/#queries","text":"Queries may be made with as SQLAlchemy Core queries , or as raw SQL. The following are supported: request.database.fetchall(query) request.database.fetchone(query) request.database.fetchval(query) request.database.execute(query)","title":"Queries"},{"location":"database/#transactions","text":"Database transactions are available either as an endpoint decorator, as a context manager, or as a low-level API. Using a decorator on an endpoint: from starlette.databases import transaction @transaction async def populate_note ( request ): # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await request . database . execute ( query ) raise RuntimeError () Using a context manager: async def populate_note ( request ): async with request . database . transaction (): # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await request . database . execute ( query ) raise RuntimeError () Using the low-level API: async def populate_note ( request ): transaction = request . database . transaction () transaction . start () try : # This database insert occurs within a transaction. # It will be rolled back by the `RuntimeError`. query = notes . insert () . values ( text = \"you won't see me\" , completed = True ) await request . database . execute ( query ) raise RuntimeError () except : transaction . rollback () raise else : transaction . commit ()","title":"Transactions"},{"location":"database/#test-isolation","text":"There are a few things that we want to ensure when running tests against a service that uses a database. Our requirements should be: Use a separate database for testing. Create a new test database every time we run the tests. Ensure that the database state is isolated between each test case. Here's how we need to structure our application and tests in order to meet those requirements: from starlette.applications import Starlette from starlette.config import Config config = Config ( \".env\" ) TESTING = config ( 'TESTING' , cast = bool , default = False ) DATABASE_URL = config ( 'DATABASE_URL' , cast = DatabaseURL ) if TESTING : # Use a database name like \"test_myapplication\" for tests. DATABASE_URL = DATABASE_URL . replace ( database = 'test_' + DATABASE_URL . database ) # Use 'rollback_on_shutdown' during testing, to ensure we have app = Starlette () app . add_middleware ( DatabaseMiddleware , database_url = DATABASE_URL , rollback_on_shutdown = TESTING ) We still need to set TESTING during a test run, and setup the test database. Assuming we're using py.test , here's how our conftest.py might look: import pytest from starlette.config import environ from starlette.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy_utils import database_exists , create_database # This sets `os.environ`, but provides some additional protection. # If we placed it below the application import, it would raise an error # informing us that 'TESTING' had already been read from the environment. environ [ 'TESTING' ] = 'True' import app @pytest.fixture ( scope = \"session\" , autouse = True ) def create_test_database (): \"\"\" Create a clean database on every test case. For safety, we should abort if a database already exists. We use the `sqlalchemy_utils` package here for a few helpers in consistently creating and dropping the database. \"\"\" url = str ( app . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. metadata . create_all ( engine ) # Create the tables. yield # Run the tests. drop_database ( url ) # Drop the test database. @pytest.fixture () def client (): \"\"\" When using the 'client' fixture in test cases, we'll get full database rollbacks between test cases: def test_homepage(client): url = app.url_path_for('homepage') response = client.get(url) assert response.status_code == 200 \"\"\" with TestClient ( app ) as client : yield client","title":"Test isolation"},{"location":"database/#migrations","text":"You'll almost certainly need to be using database migrations in order to manage incremental changes to the database. For this we'd strongly recommend Alembic , which is written by the author of SQLAlchemy. $ pip install alembic $ pip install psycopg2-binary # Install an appropriate database driver. $ alembic init migrations Now, you'll want to set things up so that Alembic references the configured DATABASE_URL, and uses your table metadata. In alembic.ini remove the following line: sqlalchemy.url = driver://user:pass@localhost/dbname In migrations/env.py , you need to set the 'sqlalchemy.url' configuration key, and the target_metadata variable. You'll want something like this: # The Alembic Config object. config = context . config # Configure Alembic to use our DATABASE_URL and our table definitions... import app config . set_main_option ( 'sqlalchemy.url' , str ( app . DATABASE_URL )) target_metadata = app . metadata ... Running migrations during testing It is good practice to ensure that your test suite runs the database migrations every time it creates the test database. This will help catch any issues in your migration scripts, and will help ensure that the tests are running against a database that's in a consistent state with your live database. We can adjust the create_test_database fixture slightly: from alembic import command from alembic.config import Config ... @pytest.fixture ( scope = \"session\" , autouse = True ) def create_test_database (): url = str ( app . DATABASE_URL ) engine = create_engine ( url ) assert not database_exists ( url ), 'Test database already exists. Aborting tests.' create_database ( url ) # Create the test database. config = Config ( \"alembic.ini\" ) # Run the migrations. command . upgrade ( config , \"head\" ) yield # Run the tests. drop_database ( url ) # Drop the test database.","title":"Migrations"},{"location":"endpoints/","text":"Starlette includes the classes HTTPEndpoint and WebSocketEndpoint that provide a class-based view pattern for handling HTTP method dispatching and WebSocket sessions. HTTPEndpoint The HTTPEndpoint class can be used as an ASGI application: from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint class App ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) If you're using a Starlette application instance to handle routing, you can dispatch to an HTTPEndpoint class by using the @app.route() decorator, or the app.add_route() function. Make sure to dispatch to the class itself, rather than to an instance of the class: from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint app = Starlette () @app.route ( \"/\" ) class Homepage ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) @app.route ( \"/{username}\" ) class User ( HTTPEndpoint ): async def get ( self , request ): username = request . path_params [ 'username' ] return PlainTextResponse ( f \"Hello, {username}\" ) HTTP endpoint classes will respond with \"405 Method not allowed\" responses for any request methods which do not map to a corresponding handler. WebSocketEndpoint The WebSocketEndpoint class is an ASGI application that presents a wrapper around the functionality of a WebSocket instance. The ASGI connection scope is accessible on the endpoint instance via .scope and has an attribute encoding which may optionally be set, in order to validate the expected websocket data in the on_receive method. The encoding types are: 'json' 'bytes' 'text' There are three overridable methods for handling specific ASGI websocket message types: async def on_connect(websocket, **kwargs) async def on_receive(websocket, data) async def on_disconnect(websocket, close_code) from starlette.endpoints import WebSocketEndpoint class App ( WebSocketEndpoint ): encoding = 'bytes' async def on_connect ( self , websocket ): await websocket . accept () async def on_receive ( self , websocket , data ): await websocket . send_bytes ( b \"Message: \" + data ) async def on_disconnect ( self , websocket , close_code ): pass The WebSocketEndpoint can also be used with the Starlette application class: import uvicorn from starlette.applications import Starlette from starlette.endpoints import WebSocketEndpoint , HTTPEndpoint from starlette.responses import HTMLResponse app = Starlette () html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" @app.route ( \"/\" ) class Homepage ( HTTPEndpoint ): async def get ( self , request ): return HTMLResponse ( html ) @app.websocket_route ( \"/ws\" ) class Echo ( WebSocketEndpoint ): encoding = \"text\" async def on_receive ( self , websocket , data ): await websocket . send_text ( f \"Message text was: {data}\" ) if __name__ == \"__main__\" : uvicorn . run ( app , host = \"0.0.0.0\" , port = 8000 )","title":"Endpoints"},{"location":"endpoints/#httpendpoint","text":"The HTTPEndpoint class can be used as an ASGI application: from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint class App ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) If you're using a Starlette application instance to handle routing, you can dispatch to an HTTPEndpoint class by using the @app.route() decorator, or the app.add_route() function. Make sure to dispatch to the class itself, rather than to an instance of the class: from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint app = Starlette () @app.route ( \"/\" ) class Homepage ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) @app.route ( \"/{username}\" ) class User ( HTTPEndpoint ): async def get ( self , request ): username = request . path_params [ 'username' ] return PlainTextResponse ( f \"Hello, {username}\" ) HTTP endpoint classes will respond with \"405 Method not allowed\" responses for any request methods which do not map to a corresponding handler.","title":"HTTPEndpoint"},{"location":"endpoints/#websocketendpoint","text":"The WebSocketEndpoint class is an ASGI application that presents a wrapper around the functionality of a WebSocket instance. The ASGI connection scope is accessible on the endpoint instance via .scope and has an attribute encoding which may optionally be set, in order to validate the expected websocket data in the on_receive method. The encoding types are: 'json' 'bytes' 'text' There are three overridable methods for handling specific ASGI websocket message types: async def on_connect(websocket, **kwargs) async def on_receive(websocket, data) async def on_disconnect(websocket, close_code) from starlette.endpoints import WebSocketEndpoint class App ( WebSocketEndpoint ): encoding = 'bytes' async def on_connect ( self , websocket ): await websocket . accept () async def on_receive ( self , websocket , data ): await websocket . send_bytes ( b \"Message: \" + data ) async def on_disconnect ( self , websocket , close_code ): pass The WebSocketEndpoint can also be used with the Starlette application class: import uvicorn from starlette.applications import Starlette from starlette.endpoints import WebSocketEndpoint , HTTPEndpoint from starlette.responses import HTMLResponse app = Starlette () html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" @app.route ( \"/\" ) class Homepage ( HTTPEndpoint ): async def get ( self , request ): return HTMLResponse ( html ) @app.websocket_route ( \"/ws\" ) class Echo ( WebSocketEndpoint ): encoding = \"text\" async def on_receive ( self , websocket , data ): await websocket . send_text ( f \"Message text was: {data}\" ) if __name__ == \"__main__\" : uvicorn . run ( app , host = \"0.0.0.0\" , port = 8000 )","title":"WebSocketEndpoint"},{"location":"events/","text":"Starlette applications can register multiple event handlers for dealing with code that needs to run before the application starts up, or when the application is shutting down. Registering events These event handlers can either be async coroutines, or regular syncronous functions. The event handlers can be registered with a decorator syntax, like so: from starlette.applications import Starlette app = Starlette () @app.on_event ( 'startup' ) async def open_database_connection_pool (): ... @app.on_event ( 'shutdown' ) async def close_database_connection_pool (): ... Or as a regular function call: from starlette.applications import Starlette app = Starlette () async def open_database_connection_pool (): ... async def close_database_connection_pool (): ... app . add_event_handler ( 'startup' , open_database_connection_pool ) app . add_event_handler ( 'shutdown' , close_database_connection_pool ) Starlette will not start serving any incoming requests until all of the registered startup handlers have completed. The shutdown handlers will run once all connections have been closed, and any in-process background tasks have completed. Note : The ASGI lifespan protocol has only recently been added to the spec, and is only currently supported by the uvicorn server. Make sure to use the latest uvicorn release if you need startup/cleanup support. Running event handlers in tests You might want to explicitly call into your event handlers in any test setup or test teardown code. Alternatively, you can use TestClient as a context manager, to ensure that startup and shutdown events are called. from example import app from starlette.lifespan import LifespanContext from starlette.testclient import TestClient def test_homepage (): with TestClient ( app ) as client : # Application 'startup' handlers are called on entering the block. response = client . get ( \"/\" ) assert response . status_code == 200 # Application 'shutdown' handlers are called on exiting the block.","title":"Events"},{"location":"events/#registering-events","text":"These event handlers can either be async coroutines, or regular syncronous functions. The event handlers can be registered with a decorator syntax, like so: from starlette.applications import Starlette app = Starlette () @app.on_event ( 'startup' ) async def open_database_connection_pool (): ... @app.on_event ( 'shutdown' ) async def close_database_connection_pool (): ... Or as a regular function call: from starlette.applications import Starlette app = Starlette () async def open_database_connection_pool (): ... async def close_database_connection_pool (): ... app . add_event_handler ( 'startup' , open_database_connection_pool ) app . add_event_handler ( 'shutdown' , close_database_connection_pool ) Starlette will not start serving any incoming requests until all of the registered startup handlers have completed. The shutdown handlers will run once all connections have been closed, and any in-process background tasks have completed. Note : The ASGI lifespan protocol has only recently been added to the spec, and is only currently supported by the uvicorn server. Make sure to use the latest uvicorn release if you need startup/cleanup support.","title":"Registering events"},{"location":"events/#running-event-handlers-in-tests","text":"You might want to explicitly call into your event handlers in any test setup or test teardown code. Alternatively, you can use TestClient as a context manager, to ensure that startup and shutdown events are called. from example import app from starlette.lifespan import LifespanContext from starlette.testclient import TestClient def test_homepage (): with TestClient ( app ) as client : # Application 'startup' handlers are called on entering the block. response = client . get ( \"/\" ) assert response . status_code == 200 # Application 'shutdown' handlers are called on exiting the block.","title":"Running event handlers in tests"},{"location":"exceptions/","text":"Starlette allows you to install custom exception handlers to deal with how you return responses when errors or handled exceptions occur. from starlette.applications import Starlette from starlette.responses import HTMLResponse HTML_404_PAGE = ... HTML_500_PAGE = ... app = Starlette () @app.exception_handler ( 404 ) async def not_found ( request , exc ): return HTMLResponse ( content = HTML_404_PAGE , status_code = exc . status_code ) @app.exception_handler ( 500 ) async def server_error ( request , exc ): return HTMLResponse ( content = HTML_500_PAGE , status_code = exc . status_code ) If debug is enabled and an error occurs, then instead of using the installed 500 handler, Starlette will respond with a traceback response. app = Starlette ( debug = True ) As well as registering handlers for specific status codes, you can also register handlers for classes of exceptions. In particular you might want to override how the built-in HTTPException class is handled. For example, to use JSON style responses: @app.exception_handler ( HTTPException ) async def http_exception ( request , exc ): return JSONResponse ({ \"detail\" : exc . detail }, status_code = exc . status_code ) Errors and handled exceptions It is important to differentiate between handled exceptions and errors. Handled exceptions do not represent error cases. They are coerced into appropriate HTTP responses, which are then sent through the standard middleware stack. By default the HTTPException class is used to manage any handled exceptions. Errors are any other exception that occurs within the application. These cases should bubble through the entire middleware stack as exceptions. Any error logging middleware should ensure that it re-raises the exception all the way up to the server. In order to deal with this behaviour correctly, the middleware stack of a Starlette application is configured like this: ServerErrorMiddleware - Returns 500 responses when server errors occur. Installed middleware ExceptionMiddleware - Deals with handled exceptions, and returns responses. Router Endpoints HTTPException The HTTPException class provides a base class that you can use for any handled exceptions. The ExceptionMiddleware implementation defaults to returning plain-text HTTP responses for any HTTPException . HTTPException(status_code, detail=None) You should only raise HTTPException inside routing or endpoints. Middleware classes should instead just return appropriate responses directly.","title":"Exceptions"},{"location":"exceptions/#errors-and-handled-exceptions","text":"It is important to differentiate between handled exceptions and errors. Handled exceptions do not represent error cases. They are coerced into appropriate HTTP responses, which are then sent through the standard middleware stack. By default the HTTPException class is used to manage any handled exceptions. Errors are any other exception that occurs within the application. These cases should bubble through the entire middleware stack as exceptions. Any error logging middleware should ensure that it re-raises the exception all the way up to the server. In order to deal with this behaviour correctly, the middleware stack of a Starlette application is configured like this: ServerErrorMiddleware - Returns 500 responses when server errors occur. Installed middleware ExceptionMiddleware - Deals with handled exceptions, and returns responses. Router Endpoints","title":"Errors and handled exceptions"},{"location":"exceptions/#httpexception","text":"The HTTPException class provides a base class that you can use for any handled exceptions. The ExceptionMiddleware implementation defaults to returning plain-text HTTP responses for any HTTPException . HTTPException(status_code, detail=None) You should only raise HTTPException inside routing or endpoints. Middleware classes should instead just return appropriate responses directly.","title":"HTTPException"},{"location":"graphql/","text":"Starlette includes optional support for GraphQL, using the graphene library. Here's an example of integrating the support into your application. from starlette.applications import Starlette from starlette.graphql import GraphQLApp import graphene class Query ( graphene . ObjectType ): hello = graphene . String ( name = graphene . String ( default_value = \"stranger\" )) def resolve_hello ( self , info , name ): return \"Hello \" + name app = Starlette () app . add_route ( '/' , GraphQLApp ( schema = graphene . Schema ( query = Query ))) If you load up the page in a browser, you'll be served the GraphiQL tool, which you can use to interact with your GraphQL API. Accessing request information The current request is available in the context. class Query ( graphene . ObjectType ): user_agent = graphene . String () def resolve_user_agent ( self , info ): \"\"\" Return the User-Agent of the incoming request. \"\"\" request = info . context [ \"request\" ] return request . headers . get ( \"User-Agent\" , \"<unknown>\" ) Adding background tasks You can add background tasks to run once the response has been sent. class Query ( graphene . ObjectType ): user_agent = graphene . String () def resolve_user_agent ( self , info ): \"\"\" Return the User-Agent of the incoming request. \"\"\" user_agent = request . headers . get ( \"User-Agent\" , \"<unknown>\" ) background = info . context [ \"background\" ] background . add_task ( log_user_agent , user_agent = user_agent ) return user_agent async def log_user_agent ( user_agent ): ... Sync or Async executors If you're working with a standard ORM, then just use regular function calls for your \"resolve\" methods, and Starlette will manage running the GraphQL query within a seperate thread. If you want to use an asyncronous ORM, then use \"async resolve\" methods, and make sure to setup Graphene's AsyncioExecutor using the executor argument. from graphql.execution.executors.asyncio import AsyncioExecutor from starlette.applications import Starlette import graphene class Query ( graphene . ObjectType ): hello = graphene . String ( name = graphene . String ( default_value = \"stranger\" )) async def resolve_hello ( self , info , name ): # We can make asynchronous network calls here. return \"Hello \" + name app = Starlette () # We're using `executor_class=AsyncioExecutor` here. app . add_route ( '/' , GraphQLApp ( schema = graphene . Schema ( query = Query ), executor_class = AsyncioExecutor ))","title":"GraphQL"},{"location":"graphql/#accessing-request-information","text":"The current request is available in the context. class Query ( graphene . ObjectType ): user_agent = graphene . String () def resolve_user_agent ( self , info ): \"\"\" Return the User-Agent of the incoming request. \"\"\" request = info . context [ \"request\" ] return request . headers . get ( \"User-Agent\" , \"<unknown>\" )","title":"Accessing request information"},{"location":"graphql/#adding-background-tasks","text":"You can add background tasks to run once the response has been sent. class Query ( graphene . ObjectType ): user_agent = graphene . String () def resolve_user_agent ( self , info ): \"\"\" Return the User-Agent of the incoming request. \"\"\" user_agent = request . headers . get ( \"User-Agent\" , \"<unknown>\" ) background = info . context [ \"background\" ] background . add_task ( log_user_agent , user_agent = user_agent ) return user_agent async def log_user_agent ( user_agent ): ...","title":"Adding background tasks"},{"location":"graphql/#sync-or-async-executors","text":"If you're working with a standard ORM, then just use regular function calls for your \"resolve\" methods, and Starlette will manage running the GraphQL query within a seperate thread. If you want to use an asyncronous ORM, then use \"async resolve\" methods, and make sure to setup Graphene's AsyncioExecutor using the executor argument. from graphql.execution.executors.asyncio import AsyncioExecutor from starlette.applications import Starlette import graphene class Query ( graphene . ObjectType ): hello = graphene . String ( name = graphene . String ( default_value = \"stranger\" )) async def resolve_hello ( self , info , name ): # We can make asynchronous network calls here. return \"Hello \" + name app = Starlette () # We're using `executor_class=AsyncioExecutor` here. app . add_route ( '/' , GraphQLApp ( schema = graphene . Schema ( query = Query ), executor_class = AsyncioExecutor ))","title":"Sync or Async executors"},{"location":"middleware/","text":"Starlette includes several middleware classes for adding behaviour that is applied across your entire application. These are all implemented as standard ASGI middleware classes, and can be applied either to Starlette or to any other ASGI application. The Starlette application class allows you to include the ASGI middleware in a way that ensures that it remains wrapped by the exception handler. from starlette.applications import Starlette from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware from starlette.middleware.trustedhost import TrustedHostMiddleware app = Starlette () # Ensure that all requests include an 'example.com' or '*.example.com' host header, # and strictly enforce https-only access. app . add_middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ]) app . add_middleware ( HTTPSRedirectMiddleware ) Starlette also allows you to add middleware functions, using a decorator syntax: @app.middleware ( \"http\" ) async def add_custom_header ( request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = 'Example' return response The following middleware implementations are available in the Starlette package: CORSMiddleware Adds appropriate CORS headers to outgoing responses in order to allow cross-origin requests from browsers. The default parameters used by the CORSMiddleware implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context. from starlette.applications import Starlette from starlette.middleware.cors import CORSMiddleware app = Starlette () app . add_middleware ( CORSMiddleware , allow_origins = [ '*' ]) The following arguments are supported: allow_origins - A list of origins that should be permitted to make cross-origin requests. eg. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin. allow_origin_regex - A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' . allow_methods - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to ['GET'] . You can use ['*'] to allow all standard methods. allow_headers - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to [] . You can use ['*'] to allow all headers. The Accept , Accept-Language , Content-Language and Content-Type headers are always allowed for CORS requests. allow_credentials - Indicate that cookies should be supported for cross-origin requests. Defaults to False . expose_headers - Indicate any response headers that should be made accessible to the browser. Defaults to [] . max_age - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to 60 . The middleware responds to two particular types of HTTP request... CORS preflight requests These are any OPTION request with Origin and Access-Control-Request-Method headers. In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a 200 or 400 response for informational purposes. Simple requests Any request with an Origin header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response. SessionMiddleware Adds signed cookie-based HTTP sessions. Session information is readable but not modifiable. Access or modify the session data using the request.session dictionary interface. The following arguments are supported: secret_key - Should be a random string. session_cookie - Defaults to \"session\". max_age - Session expiry time in seconds. Defaults to 2 weeks. same_site - SameSite flag prevents the browser from sending session cookie along with cross-site requests. Defaults to 'lax' . https_only - Indicate that Secure flag should be set (can be used with HTTPS only). Defaults to False . HTTPSRedirectMiddleware Enforces that all incoming requests must either be https or wss . Any incoming requests to http or ws will be redirected to the secure scheme instead. from starlette.applications import Starlette from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware app = Starlette () app . add_middleware ( HTTPSRedirectMiddleware ) There are no configuration options for this middleware class. TrustedHostMiddleware Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks. from starlette.applications import Starlette from starlette.middleware.trustedhost import TrustedHostMiddleware app = Starlette () app . add_middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ]) The following arguments are supported: allowed_hosts - A list of domain names that should be allowed as hostnames. Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=[\"*\"] or omit the middleware. If an incoming request does not validate correctly then a 400 response will be sent. GZipMiddleware Handles GZip responses for any request that includes \"gzip\" in the Accept-Encoding header. The middleware will handle both standard and streaming responses. from starlette.applications import Starlette from starlette.middleware.gzip import GZipMiddleware app = Starlette () app . add_middleware ( GZipMiddleware , minimum_size = 1000 ) The following arguments are supported: minimum_size - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to 500 . BaseHTTPMiddleware An abstract class that allows you to write ASGI middleware against a request/response interface, rather than dealing with ASGI messages directly. To implement a middleware class using BaseHTTPMiddleware , you must override the async def dispatch(request, call_next) method. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = 'Example' return response app = Starlette () app . add_middleware ( CustomHeaderMiddleware ) If you want to provide configuration options to the middleware class you should override the __init__ method, ensuring that the first argument is app , and any remaining arguments are optional keyword arguments. Make sure to set the app attribute on the class if you do this. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): def __init__ ( self , app , header_value = 'Example' ): self . app = app self . header_value async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = self . header_value return response app = Starlette () app . add_middleware ( CustomHeaderMiddleware , header_value = 'Customized' ) Middleware classes should not modify their state outside of the __init__ method. Instead you should keep any state local to the dispatch method, or pass it around explicitly, rather than mutating the middleware instance. Using middleware in other frameworks To wrap ASGI middleware around other ASGI applications, you should use the more general pattern of wrapping the application instance: app = TrustedHostMiddleware ( app , allowed_hosts = [ 'example.com' ]) You can do this with a Starlette application instance too, but it is preferable to use .add_middleware , as it'll ensure that you don't lose the reference to the application object, and that the exception handling always wraps around any other behaviour. Third party middleware SentryMiddleware A middleware class for logging exceptions to Sentry . ProxyHeadersMiddleware Uvicorn includes a middleware class for determining the client IP address, when proxy servers are being used, based on the X-Forwarded-Proto and X-Forwarded-For headers. For more complex proxy configurations, you might want to adapt this middleware.","title":"Middleware"},{"location":"middleware/#corsmiddleware","text":"Adds appropriate CORS headers to outgoing responses in order to allow cross-origin requests from browsers. The default parameters used by the CORSMiddleware implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context. from starlette.applications import Starlette from starlette.middleware.cors import CORSMiddleware app = Starlette () app . add_middleware ( CORSMiddleware , allow_origins = [ '*' ]) The following arguments are supported: allow_origins - A list of origins that should be permitted to make cross-origin requests. eg. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin. allow_origin_regex - A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' . allow_methods - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to ['GET'] . You can use ['*'] to allow all standard methods. allow_headers - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to [] . You can use ['*'] to allow all headers. The Accept , Accept-Language , Content-Language and Content-Type headers are always allowed for CORS requests. allow_credentials - Indicate that cookies should be supported for cross-origin requests. Defaults to False . expose_headers - Indicate any response headers that should be made accessible to the browser. Defaults to [] . max_age - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to 60 . The middleware responds to two particular types of HTTP request...","title":"CORSMiddleware"},{"location":"middleware/#cors-preflight-requests","text":"These are any OPTION request with Origin and Access-Control-Request-Method headers. In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a 200 or 400 response for informational purposes.","title":"CORS preflight requests"},{"location":"middleware/#simple-requests","text":"Any request with an Origin header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response.","title":"Simple requests"},{"location":"middleware/#sessionmiddleware","text":"Adds signed cookie-based HTTP sessions. Session information is readable but not modifiable. Access or modify the session data using the request.session dictionary interface. The following arguments are supported: secret_key - Should be a random string. session_cookie - Defaults to \"session\". max_age - Session expiry time in seconds. Defaults to 2 weeks. same_site - SameSite flag prevents the browser from sending session cookie along with cross-site requests. Defaults to 'lax' . https_only - Indicate that Secure flag should be set (can be used with HTTPS only). Defaults to False .","title":"SessionMiddleware"},{"location":"middleware/#httpsredirectmiddleware","text":"Enforces that all incoming requests must either be https or wss . Any incoming requests to http or ws will be redirected to the secure scheme instead. from starlette.applications import Starlette from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware app = Starlette () app . add_middleware ( HTTPSRedirectMiddleware ) There are no configuration options for this middleware class.","title":"HTTPSRedirectMiddleware"},{"location":"middleware/#trustedhostmiddleware","text":"Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks. from starlette.applications import Starlette from starlette.middleware.trustedhost import TrustedHostMiddleware app = Starlette () app . add_middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ]) The following arguments are supported: allowed_hosts - A list of domain names that should be allowed as hostnames. Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=[\"*\"] or omit the middleware. If an incoming request does not validate correctly then a 400 response will be sent.","title":"TrustedHostMiddleware"},{"location":"middleware/#gzipmiddleware","text":"Handles GZip responses for any request that includes \"gzip\" in the Accept-Encoding header. The middleware will handle both standard and streaming responses. from starlette.applications import Starlette from starlette.middleware.gzip import GZipMiddleware app = Starlette () app . add_middleware ( GZipMiddleware , minimum_size = 1000 ) The following arguments are supported: minimum_size - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to 500 .","title":"GZipMiddleware"},{"location":"middleware/#basehttpmiddleware","text":"An abstract class that allows you to write ASGI middleware against a request/response interface, rather than dealing with ASGI messages directly. To implement a middleware class using BaseHTTPMiddleware , you must override the async def dispatch(request, call_next) method. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = 'Example' return response app = Starlette () app . add_middleware ( CustomHeaderMiddleware ) If you want to provide configuration options to the middleware class you should override the __init__ method, ensuring that the first argument is app , and any remaining arguments are optional keyword arguments. Make sure to set the app attribute on the class if you do this. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): def __init__ ( self , app , header_value = 'Example' ): self . app = app self . header_value async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = self . header_value return response app = Starlette () app . add_middleware ( CustomHeaderMiddleware , header_value = 'Customized' ) Middleware classes should not modify their state outside of the __init__ method. Instead you should keep any state local to the dispatch method, or pass it around explicitly, rather than mutating the middleware instance.","title":"BaseHTTPMiddleware"},{"location":"middleware/#using-middleware-in-other-frameworks","text":"To wrap ASGI middleware around other ASGI applications, you should use the more general pattern of wrapping the application instance: app = TrustedHostMiddleware ( app , allowed_hosts = [ 'example.com' ]) You can do this with a Starlette application instance too, but it is preferable to use .add_middleware , as it'll ensure that you don't lose the reference to the application object, and that the exception handling always wraps around any other behaviour.","title":"Using middleware in other frameworks"},{"location":"middleware/#third-party-middleware","text":"","title":"Third party middleware"},{"location":"middleware/#sentrymiddleware","text":"A middleware class for logging exceptions to Sentry .","title":"SentryMiddleware"},{"location":"middleware/#proxyheadersmiddleware","text":"Uvicorn includes a middleware class for determining the client IP address, when proxy servers are being used, based on the X-Forwarded-Proto and X-Forwarded-For headers. For more complex proxy configurations, you might want to adapt this middleware.","title":"ProxyHeadersMiddleware"},{"location":"release-notes/","text":"0.10.0 WebSockets now default to sending/receiving JSON over text data frames. Use .send_json(data, mode=\"binary\") and .receive_json(mode=\"binary\") for binary framing. GraphQLApp now takes an executor_class argument, which should be used in preference to the existing executor argument. Resolves an issue with async executors being instantiated before the event loop was setup. The executor argument is expected to be deprecated in the next median or major release. Authentication and the @requires decorator now support WebSocket endpoints. MultiDict and ImmutableMultiDict classes are available in uvicorn.datastructures . QueryParams is now instantiated with standard dict-style *args, **kwargs arguments. 0.9.11 Session cookies now include browser 'expires', in addition to the existing signed expiry. request.form() now returns a multi-dict interface. The query parameter multi-dict implementation now mirrors dict more correctly for the behavior of .keys() , .values() , and .items() when multiple same-key items occur. Use urlsplit throughout in favor of urlparse . 0.9.10 Support @requires(...) on class methods. Apply URL escaping to form data. Support HEAD requests automatically. Add await request.is_disconnected() . Pass operationName to GraphQL executor. 0.9.9 Add TemplateResponse . Add CommaSeparatedStrings datatype. Add BackgroundTasks for multiple tasks. Common subclass for Request and WebSocket , to eg. share session functionality. Expose remote address with request.client . 0.9.8 Add request.database.executemany . 0.9.7 Ensure that AuthenticationMiddleware handles lifespan messages correctly. 0.9.6 Add AuthenticationMiddleware , and @requires() decorator. 0.9.5 Support either str or Secret for SessionMiddleware(secret_key=...) . 0.9.4 Add config.environ . Add datastructures.Secret . Add datastructures.DatabaseURL . 0.9.3 Add config.Config(\".env\") 0.9.2 Add optional database support. Add request to GraphQL context. Hide any password component in URL.__repr__ . 0.9.1 Handle startup/shutdown errors properly. 0.9.0 TestClient can now be used as a context manager, instead of LifespanContext . Lifespan is now handled as middleware. Startup and Shutdown events are visible throughout the middleware stack. 0.8.8 Better support for third-party API schema generators. 0.8.7 Support chunked requests with TestClient. Cleanup asyncio tasks properly with WSGIMiddleware. Support using TestClient within endpoints, for service mocking. 0.8.6 Session cookies are now set on the root path. 0.8.5 Support URL convertors. Support HTTP 304 cache responses from StaticFiles . Resolve character escaping issue with form data. 0.8.4 Default to empty body on responses. 0.8.3 Add 'name' argument to @app.route() . Use 'Host' header for URL reconstruction. 0.8.2 StaticFiles StaticFiles no longer reads the file for responses to HEAD requests. 0.8.1 Templating Add a default templating configuration with Jinja2. Allows the following: app = Starlette ( template_directory = \"templates\" ) @app.route ( '/' ) async def homepage ( request ): # `url_for` is available inside the template. template = app . get_template ( 'index.html' ) content = template . render ( request = request ) return HTMLResponse ( content ) 0.8.0 Exceptions Add support for @app.exception_handler(404) . Ensure handled exceptions are not seen as errors by the middleware stack. SessionMiddleware Add max_age , and use timestamp-signed cookies. Defaults to two weeks. Cookies Ensure cookies are strictly HTTP correct. StaticFiles Check directory exists on instantiation. 0.7.4 Concurrency Add starlette.concurrency.run_in_threadpool . Now handles contextvar support. 0.7.3 Routing Add name= support to app.mount() . This allows eg: app.mount('/static', StaticFiles(directory='static'), name='static') . 0.7.2 Middleware Add support for @app.middleware(\"http\") decorator. Routing Add \"endpoint\" to ASGI scope. 0.7.1 Debug tracebacks Improve debug traceback information & styling. URL routing Support mounted URL lookups with \"path=\", eg. url_for('static', path=...) . Support nested URL lookups, eg. url_for('admin:user', username=...) . Add redirect slashes support. Add www redirect support. Background tasks Add background task support to FileResponse and StreamingResponse . 0.7.0 API Schema support Add app.schema_generator = SchemaGenerator(...) . Add app.schema property. Add OpenAPIResponse(...) . GraphQL routing Drop app.add_graphql_route(\"/\", ...) in favor of more consistent app.add_route(\"/\", GraphQLApp(...)) . 0.6.3 Routing API Support routing to methods. Ensure url_path_for works with Mount('/{some_path_params}'). Fix Router(default=) argument. Support repeated paths, like: @app.route(\"/\", methods=[\"GET\"]) , @app.route(\"/\", methods=[\"POST\"]) Use the default ThreadPoolExecutor for all sync endpoints. 0.6.2 SessionMiddleware Added support for request.session , with SessionMiddleware . 0.6.1 BaseHTTPMiddleware Added support for BaseHTTPMiddleware , which provides a standard request/response interface over a regular ASGI middleware. This means you can write ASGI middleware while still working at a request/response level, rather than handling ASGI messages directly. from starlette.applications import Starlette from starlette.middleware.base import BaseHTTPMiddleware class CustomMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom-Header' ] = 'Example' return response app = Starlette () app . add_middleware ( CustomMiddleware ) 0.6.0 request.path_params The biggest change in 0.6 is that endpoint signatures are no longer: async def func ( request : Request , ** kwargs ) -> Response Instead we just use: async def func ( request : Request ) -> Response The path parameters are available on the request as request.path_params . This is different to most Python webframeworks, but I think it actually ends up being much more nicely consistent all the way through. request.url_for() Request and WebSocketSession now support URL reversing with request.url_for(name, **path_params) . This method returns a fully qualified URL instance. The URL instance is a string-like object. app.url_path_for() Applications now support URL path reversing with app.url_path_for(name, **path_params) . This method returns a URL instance with the path and scheme set. The URL instance is a string-like object, and will return only the path if coerced to a string. app.routes Applications now support a .routes parameter, which returns a list of [Route|WebSocketRoute|Mount] . Route, WebSocketRoute, Mount The low level components to Router now match the @app.route() , @app.websocket_route() , and app.mount() signatures.","title":"Release Notes"},{"location":"release-notes/#0100","text":"WebSockets now default to sending/receiving JSON over text data frames. Use .send_json(data, mode=\"binary\") and .receive_json(mode=\"binary\") for binary framing. GraphQLApp now takes an executor_class argument, which should be used in preference to the existing executor argument. Resolves an issue with async executors being instantiated before the event loop was setup. The executor argument is expected to be deprecated in the next median or major release. Authentication and the @requires decorator now support WebSocket endpoints. MultiDict and ImmutableMultiDict classes are available in uvicorn.datastructures . QueryParams is now instantiated with standard dict-style *args, **kwargs arguments.","title":"0.10.0"},{"location":"release-notes/#0911","text":"Session cookies now include browser 'expires', in addition to the existing signed expiry. request.form() now returns a multi-dict interface. The query parameter multi-dict implementation now mirrors dict more correctly for the behavior of .keys() , .values() , and .items() when multiple same-key items occur. Use urlsplit throughout in favor of urlparse .","title":"0.9.11"},{"location":"release-notes/#0910","text":"Support @requires(...) on class methods. Apply URL escaping to form data. Support HEAD requests automatically. Add await request.is_disconnected() . Pass operationName to GraphQL executor.","title":"0.9.10"},{"location":"release-notes/#099","text":"Add TemplateResponse . Add CommaSeparatedStrings datatype. Add BackgroundTasks for multiple tasks. Common subclass for Request and WebSocket , to eg. share session functionality. Expose remote address with request.client .","title":"0.9.9"},{"location":"release-notes/#098","text":"Add request.database.executemany .","title":"0.9.8"},{"location":"release-notes/#097","text":"Ensure that AuthenticationMiddleware handles lifespan messages correctly.","title":"0.9.7"},{"location":"release-notes/#096","text":"Add AuthenticationMiddleware , and @requires() decorator.","title":"0.9.6"},{"location":"release-notes/#095","text":"Support either str or Secret for SessionMiddleware(secret_key=...) .","title":"0.9.5"},{"location":"release-notes/#094","text":"Add config.environ . Add datastructures.Secret . Add datastructures.DatabaseURL .","title":"0.9.4"},{"location":"release-notes/#093","text":"Add config.Config(\".env\")","title":"0.9.3"},{"location":"release-notes/#092","text":"Add optional database support. Add request to GraphQL context. Hide any password component in URL.__repr__ .","title":"0.9.2"},{"location":"release-notes/#091","text":"Handle startup/shutdown errors properly.","title":"0.9.1"},{"location":"release-notes/#090","text":"TestClient can now be used as a context manager, instead of LifespanContext . Lifespan is now handled as middleware. Startup and Shutdown events are visible throughout the middleware stack.","title":"0.9.0"},{"location":"release-notes/#088","text":"Better support for third-party API schema generators.","title":"0.8.8"},{"location":"release-notes/#087","text":"Support chunked requests with TestClient. Cleanup asyncio tasks properly with WSGIMiddleware. Support using TestClient within endpoints, for service mocking.","title":"0.8.7"},{"location":"release-notes/#086","text":"Session cookies are now set on the root path.","title":"0.8.6"},{"location":"release-notes/#085","text":"Support URL convertors. Support HTTP 304 cache responses from StaticFiles . Resolve character escaping issue with form data.","title":"0.8.5"},{"location":"release-notes/#084","text":"Default to empty body on responses.","title":"0.8.4"},{"location":"release-notes/#083","text":"Add 'name' argument to @app.route() . Use 'Host' header for URL reconstruction.","title":"0.8.3"},{"location":"release-notes/#082","text":"","title":"0.8.2"},{"location":"release-notes/#staticfiles","text":"StaticFiles no longer reads the file for responses to HEAD requests.","title":"StaticFiles"},{"location":"release-notes/#081","text":"","title":"0.8.1"},{"location":"release-notes/#templating","text":"Add a default templating configuration with Jinja2. Allows the following: app = Starlette ( template_directory = \"templates\" ) @app.route ( '/' ) async def homepage ( request ): # `url_for` is available inside the template. template = app . get_template ( 'index.html' ) content = template . render ( request = request ) return HTMLResponse ( content )","title":"Templating"},{"location":"release-notes/#080","text":"","title":"0.8.0"},{"location":"release-notes/#exceptions","text":"Add support for @app.exception_handler(404) . Ensure handled exceptions are not seen as errors by the middleware stack.","title":"Exceptions"},{"location":"release-notes/#sessionmiddleware","text":"Add max_age , and use timestamp-signed cookies. Defaults to two weeks.","title":"SessionMiddleware"},{"location":"release-notes/#cookies","text":"Ensure cookies are strictly HTTP correct.","title":"Cookies"},{"location":"release-notes/#staticfiles_1","text":"Check directory exists on instantiation.","title":"StaticFiles"},{"location":"release-notes/#074","text":"","title":"0.7.4"},{"location":"release-notes/#concurrency","text":"Add starlette.concurrency.run_in_threadpool . Now handles contextvar support.","title":"Concurrency"},{"location":"release-notes/#073","text":"","title":"0.7.3"},{"location":"release-notes/#routing","text":"Add name= support to app.mount() . This allows eg: app.mount('/static', StaticFiles(directory='static'), name='static') .","title":"Routing"},{"location":"release-notes/#072","text":"","title":"0.7.2"},{"location":"release-notes/#middleware","text":"Add support for @app.middleware(\"http\") decorator.","title":"Middleware"},{"location":"release-notes/#routing_1","text":"Add \"endpoint\" to ASGI scope.","title":"Routing"},{"location":"release-notes/#071","text":"","title":"0.7.1"},{"location":"release-notes/#debug-tracebacks","text":"Improve debug traceback information & styling.","title":"Debug tracebacks"},{"location":"release-notes/#url-routing","text":"Support mounted URL lookups with \"path=\", eg. url_for('static', path=...) . Support nested URL lookups, eg. url_for('admin:user', username=...) . Add redirect slashes support. Add www redirect support.","title":"URL routing"},{"location":"release-notes/#background-tasks","text":"Add background task support to FileResponse and StreamingResponse .","title":"Background tasks"},{"location":"release-notes/#070","text":"","title":"0.7.0"},{"location":"release-notes/#api-schema-support","text":"Add app.schema_generator = SchemaGenerator(...) . Add app.schema property. Add OpenAPIResponse(...) .","title":"API Schema support"},{"location":"release-notes/#graphql-routing","text":"Drop app.add_graphql_route(\"/\", ...) in favor of more consistent app.add_route(\"/\", GraphQLApp(...)) .","title":"GraphQL routing"},{"location":"release-notes/#063","text":"","title":"0.6.3"},{"location":"release-notes/#routing-api","text":"Support routing to methods. Ensure url_path_for works with Mount('/{some_path_params}'). Fix Router(default=) argument. Support repeated paths, like: @app.route(\"/\", methods=[\"GET\"]) , @app.route(\"/\", methods=[\"POST\"]) Use the default ThreadPoolExecutor for all sync endpoints.","title":"Routing API"},{"location":"release-notes/#062","text":"","title":"0.6.2"},{"location":"release-notes/#sessionmiddleware_1","text":"Added support for request.session , with SessionMiddleware .","title":"SessionMiddleware"},{"location":"release-notes/#061","text":"","title":"0.6.1"},{"location":"release-notes/#basehttpmiddleware","text":"Added support for BaseHTTPMiddleware , which provides a standard request/response interface over a regular ASGI middleware. This means you can write ASGI middleware while still working at a request/response level, rather than handling ASGI messages directly. from starlette.applications import Starlette from starlette.middleware.base import BaseHTTPMiddleware class CustomMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom-Header' ] = 'Example' return response app = Starlette () app . add_middleware ( CustomMiddleware )","title":"BaseHTTPMiddleware"},{"location":"release-notes/#060","text":"","title":"0.6.0"},{"location":"release-notes/#requestpath_params","text":"The biggest change in 0.6 is that endpoint signatures are no longer: async def func ( request : Request , ** kwargs ) -> Response Instead we just use: async def func ( request : Request ) -> Response The path parameters are available on the request as request.path_params . This is different to most Python webframeworks, but I think it actually ends up being much more nicely consistent all the way through.","title":"request.path_params"},{"location":"release-notes/#requesturl_for","text":"Request and WebSocketSession now support URL reversing with request.url_for(name, **path_params) . This method returns a fully qualified URL instance. The URL instance is a string-like object.","title":"request.url_for()"},{"location":"release-notes/#appurl_path_for","text":"Applications now support URL path reversing with app.url_path_for(name, **path_params) . This method returns a URL instance with the path and scheme set. The URL instance is a string-like object, and will return only the path if coerced to a string.","title":"app.url_path_for()"},{"location":"release-notes/#approutes","text":"Applications now support a .routes parameter, which returns a list of [Route|WebSocketRoute|Mount] .","title":"app.routes"},{"location":"release-notes/#route-websocketroute-mount","text":"The low level components to Router now match the @app.route() , @app.websocket_route() , and app.mount() signatures.","title":"Route, WebSocketRoute, Mount"},{"location":"requests/","text":"Starlette includes a Request class that gives you a nicer interface onto the incoming request, rather than accessing the ASGI scope and receive channel directly. Request Signature: Request(scope, receive=None) from starlette.requests import Request from starlette.response import Response class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): request = Request ( self . scope , receive ) content = ' %s %s ' % ( request . method , request . url . path ) response = Response ( content , media_type = 'text/plain' ) await response ( receive , send ) Requests present a mapping interface, so you can use them in the same way as a scope . For instance: request['path'] will return the ASGI path. If you don't need to access the request body you can instantiate a request without providing an argument to receive . Method The request method is accessed as request.method . URL The request URL is accessed as request.url . The property is a string-like object that exposes all the components that can be parsed out of the URL. For example: request.url.path , request.url.port , request.url.scheme . Headers Headers are exposed as an immutable, case-insensitive, multi-dict. For example: request.headers['content-type'] Query Parameters Query parameters are exposed as an immutable multi-dict. For example: request.query_params['search'] Path Parameters Router path parameters are exposed as a dictionary interface. For example: request.path_params['username'] Client Address The client's remote address is exposed as a named two-tuple request.client . Either item in the tuple may be None . The hostname or IP address: request.client.host The port number from which the client is connecting: request.client.port Cookies Cookies are exposed as a regular dictionary interface. For example: request.cookies.get('mycookie') Body There are a few different interfaces for returning the body of the request: The request body as bytes: await request.body() The request body, parsed as form data or multipart: await request.form() The request body, parsed as JSON: await request.json() You can also access the request body as a stream, using the async for syntax: from starlette.requests import Request from starlette.responses import Response class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): request = Request ( self . scope , receive ) body = b '' async for chunk in request . stream (): body += chunk response = Response ( body , media_type = 'text/plain' ) await response ( receive , send ) If you access .stream() then the byte chunks are provided without storing the entire body to memory. Any subsequent calls to .body() , .form() , or .json() will raise an error. In some cases such as long-polling, or streaming responses you might need to determine if the client has dropped the connection. You can determine this state with disconnected = await request.is_disconnected() .","title":"Requests"},{"location":"requests/#request","text":"Signature: Request(scope, receive=None) from starlette.requests import Request from starlette.response import Response class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): request = Request ( self . scope , receive ) content = ' %s %s ' % ( request . method , request . url . path ) response = Response ( content , media_type = 'text/plain' ) await response ( receive , send ) Requests present a mapping interface, so you can use them in the same way as a scope . For instance: request['path'] will return the ASGI path. If you don't need to access the request body you can instantiate a request without providing an argument to receive .","title":"Request"},{"location":"requests/#method","text":"The request method is accessed as request.method .","title":"Method"},{"location":"requests/#url","text":"The request URL is accessed as request.url . The property is a string-like object that exposes all the components that can be parsed out of the URL. For example: request.url.path , request.url.port , request.url.scheme .","title":"URL"},{"location":"requests/#headers","text":"Headers are exposed as an immutable, case-insensitive, multi-dict. For example: request.headers['content-type']","title":"Headers"},{"location":"requests/#query-parameters","text":"Query parameters are exposed as an immutable multi-dict. For example: request.query_params['search']","title":"Query Parameters"},{"location":"requests/#path-parameters","text":"Router path parameters are exposed as a dictionary interface. For example: request.path_params['username']","title":"Path Parameters"},{"location":"requests/#client-address","text":"The client's remote address is exposed as a named two-tuple request.client . Either item in the tuple may be None . The hostname or IP address: request.client.host The port number from which the client is connecting: request.client.port","title":"Client Address"},{"location":"requests/#cookies","text":"Cookies are exposed as a regular dictionary interface. For example: request.cookies.get('mycookie')","title":"Cookies"},{"location":"requests/#body","text":"There are a few different interfaces for returning the body of the request: The request body as bytes: await request.body() The request body, parsed as form data or multipart: await request.form() The request body, parsed as JSON: await request.json() You can also access the request body as a stream, using the async for syntax: from starlette.requests import Request from starlette.responses import Response class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): request = Request ( self . scope , receive ) body = b '' async for chunk in request . stream (): body += chunk response = Response ( body , media_type = 'text/plain' ) await response ( receive , send ) If you access .stream() then the byte chunks are provided without storing the entire body to memory. Any subsequent calls to .body() , .form() , or .json() will raise an error. In some cases such as long-polling, or streaming responses you might need to determine if the client has dropped the connection. You can determine this state with disconnected = await request.is_disconnected() .","title":"Body"},{"location":"responses/","text":"Starlette includes a few response classes that handle sending back the appropriate ASGI messages on the send channel. Response Signature: Response(content, status_code=200, headers=None, media_type=None) content - A string or bytestring. status_code - An integer HTTP status code. headers - A dictionary of strings. media_type - A string giving the media type. eg. \"text/html\" Starlette will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types. Once you've instantiated a response, you can send it by calling it as an ASGI application instance. from starlette.responses import Response class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = Response ( 'Hello, world!' , media_type = 'text/plain' ) await response ( receive , send ) Set Cookie Starlette provides a set_cookie method to allow you to set cookies on the response object. Signature: Response.set_cookie(key, value, max_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False) key - A string that will be the cookie's key. value - A string that will be the cookie's value. max_age - An integer that defines the lifetime of the cookie in seconds. A negative integer or a value of 0 will discard the cookie immediately. Optional expires - An integer that defines the number of seconds until the cookie expires. Optional path - A string that specifies the subset of routes to which the cookie will apply. Optional domain - A string that specifies the domain for which the cookie is valid. Optional secure - A bool indicating that the cookie will only be sent to the server if request is made using SSL and the HTTPS protocol. Optional httponly - A bool indicating that the cookie cannot be accessed via Javascript through Document.cookie property, the XMLHttpRequest or Request APIs. Optional Delete Cookie Conversly, Starlette also provides a delete_cookie method to manually expire a set cookie. Signature: Response.delete_cookie(key, path='/', domain=None) HTMLResponse Takes some text or bytes and returns an HTML response. from starlette.responses import HTMLResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = HTMLResponse ( '<html><body><h1>Hello, world!</h1></body></html>' ) await response ( receive , send ) PlainTextResponse Takes some text or bytes and returns an plain text response. from starlette.responses import PlainTextResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send ) TemplateResponse The TemplateResponse class return plain text responses generated from a template instance, and a dictionary of context to render into the template. A request argument must always be included in the context. Responses default to text/html unless an alternative media_type is specified. from starlette.responses import TemplateResponse from starlette.requests import Request from jinja2 import Environment , FileSystemLoader env = Environment ( loader = FileSystemLoader ( 'templates' )) class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): template = env . get_template ( 'index.html' ) context = { 'request' : Request ( self . scope ), } response = TemplateResponse ( template , context ) await response ( receive , send ) The advantage with using TemplateResponse over HTMLResponse is that it will make template and context properties available on response instances returned by the test client. def test_app (): client = TestClient ( App ) response = client . get ( \"/\" ) assert response . status_code == 200 assert response . template . name == \"index.html\" assert \"request\" in response . context JSONResponse Takes some data and returns an application/json encoded response. from starlette.responses import JSONResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = JSONResponse ({ 'hello' : 'world' }) await response ( receive , send ) UJSONResponse A JSON response class that uses the optimised ujson library for serialisation. Using ujson will result in faster JSON serialisation, but is also less careful than Python's built-in implementation in how it handles some edge-cases. In general you probably want to stick with JSONResponse by default unless you are micro-optimising a particular endpoint. from starlette.responses import UJSONResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = UJSONResponse ({ 'hello' : 'world' }) await response ( receive , send ) RedirectResponse Returns an HTTP redirect. Uses a 302 status code by default. from starlette.responses import PlainTextResponse , RedirectResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): if self . scope [ 'path' ] != '/' : response = RedirectResponse ( url = '/' ) else : response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send ) StreamingResponse Takes an async generator and streams the response body. from starlette.responses import StreamingResponse import asyncio async def slow_numbers ( minimum , maximum ): yield ( '<html><body><ul>' ) for number in range ( minimum , maximum + 1 ): yield '<li> %d </li>' % number await asyncio . sleep ( 0.5 ) yield ( '</ul></body></html>' ) class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): generator = slow_numbers ( 1 , 10 ) response = StreamingResponse ( generator , media_type = 'text/html' ) await response ( receive , send ) FileResponse Asynchronously streams a file as the response. Takes a different set of arguments to instantiate than the other response types: path - The filepath to the file to stream. headers - Any custom headers to include, as a dictionary. media_type - A string giving the media type. If unset, the filename or path will be used to infer a media type. filename - If set, this will be included in the response Content-Disposition . File responses will include appropriate Content-Length , Last-Modified and ETag headers. from starlette.responses import FileResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = FileResponse ( 'statics/favicon.ico' ) await response ( receive , send )","title":"Responses"},{"location":"responses/#response","text":"Signature: Response(content, status_code=200, headers=None, media_type=None) content - A string or bytestring. status_code - An integer HTTP status code. headers - A dictionary of strings. media_type - A string giving the media type. eg. \"text/html\" Starlette will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types. Once you've instantiated a response, you can send it by calling it as an ASGI application instance. from starlette.responses import Response class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = Response ( 'Hello, world!' , media_type = 'text/plain' ) await response ( receive , send )","title":"Response"},{"location":"responses/#set-cookie","text":"Starlette provides a set_cookie method to allow you to set cookies on the response object. Signature: Response.set_cookie(key, value, max_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False) key - A string that will be the cookie's key. value - A string that will be the cookie's value. max_age - An integer that defines the lifetime of the cookie in seconds. A negative integer or a value of 0 will discard the cookie immediately. Optional expires - An integer that defines the number of seconds until the cookie expires. Optional path - A string that specifies the subset of routes to which the cookie will apply. Optional domain - A string that specifies the domain for which the cookie is valid. Optional secure - A bool indicating that the cookie will only be sent to the server if request is made using SSL and the HTTPS protocol. Optional httponly - A bool indicating that the cookie cannot be accessed via Javascript through Document.cookie property, the XMLHttpRequest or Request APIs. Optional","title":"Set Cookie"},{"location":"responses/#delete-cookie","text":"Conversly, Starlette also provides a delete_cookie method to manually expire a set cookie. Signature: Response.delete_cookie(key, path='/', domain=None)","title":"Delete Cookie"},{"location":"responses/#htmlresponse","text":"Takes some text or bytes and returns an HTML response. from starlette.responses import HTMLResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = HTMLResponse ( '<html><body><h1>Hello, world!</h1></body></html>' ) await response ( receive , send )","title":"HTMLResponse"},{"location":"responses/#plaintextresponse","text":"Takes some text or bytes and returns an plain text response. from starlette.responses import PlainTextResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send )","title":"PlainTextResponse"},{"location":"responses/#templateresponse","text":"The TemplateResponse class return plain text responses generated from a template instance, and a dictionary of context to render into the template. A request argument must always be included in the context. Responses default to text/html unless an alternative media_type is specified. from starlette.responses import TemplateResponse from starlette.requests import Request from jinja2 import Environment , FileSystemLoader env = Environment ( loader = FileSystemLoader ( 'templates' )) class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): template = env . get_template ( 'index.html' ) context = { 'request' : Request ( self . scope ), } response = TemplateResponse ( template , context ) await response ( receive , send ) The advantage with using TemplateResponse over HTMLResponse is that it will make template and context properties available on response instances returned by the test client. def test_app (): client = TestClient ( App ) response = client . get ( \"/\" ) assert response . status_code == 200 assert response . template . name == \"index.html\" assert \"request\" in response . context","title":"TemplateResponse"},{"location":"responses/#jsonresponse","text":"Takes some data and returns an application/json encoded response. from starlette.responses import JSONResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = JSONResponse ({ 'hello' : 'world' }) await response ( receive , send )","title":"JSONResponse"},{"location":"responses/#ujsonresponse","text":"A JSON response class that uses the optimised ujson library for serialisation. Using ujson will result in faster JSON serialisation, but is also less careful than Python's built-in implementation in how it handles some edge-cases. In general you probably want to stick with JSONResponse by default unless you are micro-optimising a particular endpoint. from starlette.responses import UJSONResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = UJSONResponse ({ 'hello' : 'world' }) await response ( receive , send )","title":"UJSONResponse"},{"location":"responses/#redirectresponse","text":"Returns an HTTP redirect. Uses a 302 status code by default. from starlette.responses import PlainTextResponse , RedirectResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): if self . scope [ 'path' ] != '/' : response = RedirectResponse ( url = '/' ) else : response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send )","title":"RedirectResponse"},{"location":"responses/#streamingresponse","text":"Takes an async generator and streams the response body. from starlette.responses import StreamingResponse import asyncio async def slow_numbers ( minimum , maximum ): yield ( '<html><body><ul>' ) for number in range ( minimum , maximum + 1 ): yield '<li> %d </li>' % number await asyncio . sleep ( 0.5 ) yield ( '</ul></body></html>' ) class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): generator = slow_numbers ( 1 , 10 ) response = StreamingResponse ( generator , media_type = 'text/html' ) await response ( receive , send )","title":"StreamingResponse"},{"location":"responses/#fileresponse","text":"Asynchronously streams a file as the response. Takes a different set of arguments to instantiate than the other response types: path - The filepath to the file to stream. headers - Any custom headers to include, as a dictionary. media_type - A string giving the media type. If unset, the filename or path will be used to infer a media type. filename - If set, this will be included in the response Content-Disposition . File responses will include appropriate Content-Length , Last-Modified and ETag headers. from starlette.responses import FileResponse class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = FileResponse ( 'statics/favicon.ico' ) await response ( receive , send )","title":"FileResponse"},{"location":"routing/","text":"Starlette includes a Router class which is an ASGI application that dispatches incoming requests to endpoints or submounted applications. from starlette.routing import Mount , Route , Router from myproject import Homepage , SubMountedApp app = Router ([ Route ( '/' , endpoint = Homepage , methods = [ 'GET' ]), Mount ( '/mount' , app = SubMountedApp ) ]) Paths can use URI templating style to capture path components. Route ( '/users/{username}' , endpoint = User , methods = [ 'GET' ]) Convertors for int , float , and path are also available: Route ( '/users/{user_id:int}' , endpoint = User , methods = [ 'GET' ]) Path parameters are made available in the request, as the request.path_params dictionary. Because the target of a Mount is an ASGI instance itself, routers allow for easy composition. For example: app = Router ([ Route ( '/' , endpoint = Homepage , methods = [ 'GET' ]), Mount ( '/users' , app = Router ([ Route ( '/' , endpoint = Users , methods = [ 'GET' , 'POST' ]), Route ( '/{username}' , endpoint = User , methods = [ 'GET' ]), ])) ]) The router will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match. Incoming paths are matched against each Route in order. If you need to have a Route with a fixed path that would also match a Route with parameters you should add the Route with the fixed path first. For example, with an additional Route like: Route ( '/users/me' , endpoint = UserMe , methods = [ 'GET' ]) You should add that route for /users/me before the one for /users/{username} : app = Router ([ Route ( '/users/me' , endpoint = UserMe , methods = [ 'GET' ]), Route ( '/{username}' , endpoint = User , methods = [ 'GET' ]), ])","title":"Routing"},{"location":"schemas/","text":"Starlette supports generating API schemas, such as the widely used OpenAPI specification . (Formerly known as \"Swagger\".) Schema generation works by inspecting the routes on the application through app.routes , and using the docstrings or other attributes on the endpoints in order to determine a complete API schema. Starlette is not tied to any particular schema generation or validation tooling, but includes a simple implementation that generates OpenAPI schemas based on the docstrings. from starlette.applications import Starlette from starlette.schemas import SchemaGenerator , OpenAPIResponse app = Starlette () app . schema_generator = SchemaGenerator ( { \"openapi\" : \"3.0.0\" , \"info\" : { \"title\" : \"Example API\" , \"version\" : \"1.0\" }} ) @app.route ( \"/users\" , methods = [ \"GET\" ]) def list_users ( request ): \"\"\" responses: 200: description: A list of users. examples: [{\"username\": \"tom\"}, {\"username\": \"lucy\"}] \"\"\" raise NotImplementedError () @app.route ( \"/users\" , methods = [ \"POST\" ]) def create_user ( request ): \"\"\" responses: 200: description: A user. examples: {\"username\": \"tom\"} \"\"\" raise NotImplementedError () @app.route ( \"/schema\" , methods = [ \"GET\" ], include_in_schema = False ) def schema ( request ): return OpenAPIResponse ( app . schema ) We can now access an OpenAPI schema at the \"/schema\" endpoint. You can inspect the API Schema directly by accessing app.schema : assert app . schema == { \"openapi\" : \"3.0.0\" , \"info\" : { \"title\" : \"Example API\" , \"version\" : \"1.0\" }, \"paths\" : { \"/users\" : { \"get\" : { \"responses\" : { 200 : { \"description\" : \"A list of users.\" , \"examples\" : [{ \"username\" : \"tom\" }, { \"username\" : \"lucy\" }], } } }, \"post\" : { \"responses\" : { 200 : { \"description\" : \"A user.\" , \"examples\" : { \"username\" : \"tom\" }} } }, }, }, } You might also want to be able to print out the API schema, so that you can use tooling such as generating API documentation. if __name__ == '__main__' : assert sys . argv [ - 1 ] in ( \"run\" , \"schema\" ), \"Usage: example.py [run|schema]\" if sys . argv [ - 1 ] == \"run\" : uvicorn . run ( app , host = '0.0.0.0' , port = 8000 ) elif sys . arvg [ - 1 ] == \"schema\" : print ( yaml . dump ( app . schema , default_flow_style = False )) Third party packages starlette-apispec Easy APISpec integration for Starlette, which supports some object serialization libraries.","title":"API Schemas"},{"location":"schemas/#third-party-packages","text":"","title":"Third party packages"},{"location":"schemas/#starlette-apispec","text":"Easy APISpec integration for Starlette, which supports some object serialization libraries.","title":"starlette-apispec"},{"location":"staticfiles/","text":"Starlette also includes a StaticFiles class for serving files in a given directory: StaticFiles Signature: StaticFiles(directory, check_dir=True) directory - A string denoting the directory path check_dir - Ensure that the directory exists upon instantiation. Defaults to True You can combine this ASGI application with Starlette's routing to provide comprehensive static file serving. from starlette.routing import Router , Mount from starlette.staticfiles import StaticFiles app = Router ( routes = [ Mount ( '/static' , app = StaticFiles ( directory = 'static' )), ]) Static files will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match.","title":"Static Files"},{"location":"staticfiles/#staticfiles","text":"Signature: StaticFiles(directory, check_dir=True) directory - A string denoting the directory path check_dir - Ensure that the directory exists upon instantiation. Defaults to True You can combine this ASGI application with Starlette's routing to provide comprehensive static file serving. from starlette.routing import Router , Mount from starlette.staticfiles import StaticFiles app = Router ( routes = [ Mount ( '/static' , app = StaticFiles ( directory = 'static' )), ]) Static files will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match.","title":"StaticFiles"},{"location":"templates/","text":"Starlette is not strictly coupled to any particular templating engine, but Jinja2 provides an excellent choice. The Starlette application class provides a simple way to get jinja2 configured. This is probably what you want to use by default. app = Starlette ( debug = True , template_directory = 'templates' ) app . mount ( '/static' , StaticFiles ( directory = 'statics' ), name = 'static' ) @app.route ( '/' ) async def homepage ( request ): template = app . get_template ( 'index.html' ) content = template . render ( request = request ) return HTMLResponse ( content ) If you include request in the template context, then the url_for function will also be available within your template code. The Jinja2 Environment instance is available as app.template_env . Handling templates explicitly If you don't want to use jinja2 , or you don't want to rely on Starlette's default configuration you can configure a template renderer explicitly instead. Here we're going to take a look at an example of how you can explicitly configure a Jinja2 environment together with Starlette. from starlette.applications import Starlette from starlette.staticfiles import StaticFiles from starlette.responses import HTMLResponse def setup_jinja2 ( template_dir ): @jinja2.contextfunction def url_for ( context , name , ** path_params ): request = context [ 'request' ] return request . url_for ( name , ** path_params ) loader = jinja2 . FileSystemLoader ( template_dir ) env = jinja2 . Environment ( loader = loader , autoescape = True ) env . globals [ 'url_for' ] = url_for return env env = setup_jinja2 ( 'templates' ) app = Starlette ( debug = True ) app . mount ( '/static' , StaticFiles ( directory = 'statics' ), name = 'static' ) @app.route ( '/' ) async def homepage ( request ): template = env . get_template ( 'index.html' ) content = template . render ( request = request ) return HTMLResponse ( content ) This gives you the equivalent of the default app.get_template() , but we've got all the configuration explicitly out in the open now. The important parts to note from the above example are: The StaticFiles app has been mounted with name='static' , meaning we can use app.url_path_for('static', path=...) or request.url_for('static', path=...) . The Jinja2 environment has a global url_for included, which allows us to use url_for inside our templates. We always need to pass the incoming request instance in our context in order to be able to use the url_for function. We can now link to static files from within our HTML templates. For example: < link href = \"{{ url_for('static', path='/css/bootstrap.min.css') }}\" rel = \"stylesheet\" > Asynchronous template rendering Jinja2 supports async template rendering, however as a general rule we'd recommend that you keep your templates free from logic that invokes database lookups, or other I/O operations. Instead we'd recommend that you ensure that your views perform all I/O, for example, strictly evaluate any database queries within the view and include the final results in the context.","title":"Templates"},{"location":"templates/#handling-templates-explicitly","text":"If you don't want to use jinja2 , or you don't want to rely on Starlette's default configuration you can configure a template renderer explicitly instead. Here we're going to take a look at an example of how you can explicitly configure a Jinja2 environment together with Starlette. from starlette.applications import Starlette from starlette.staticfiles import StaticFiles from starlette.responses import HTMLResponse def setup_jinja2 ( template_dir ): @jinja2.contextfunction def url_for ( context , name , ** path_params ): request = context [ 'request' ] return request . url_for ( name , ** path_params ) loader = jinja2 . FileSystemLoader ( template_dir ) env = jinja2 . Environment ( loader = loader , autoescape = True ) env . globals [ 'url_for' ] = url_for return env env = setup_jinja2 ( 'templates' ) app = Starlette ( debug = True ) app . mount ( '/static' , StaticFiles ( directory = 'statics' ), name = 'static' ) @app.route ( '/' ) async def homepage ( request ): template = env . get_template ( 'index.html' ) content = template . render ( request = request ) return HTMLResponse ( content ) This gives you the equivalent of the default app.get_template() , but we've got all the configuration explicitly out in the open now. The important parts to note from the above example are: The StaticFiles app has been mounted with name='static' , meaning we can use app.url_path_for('static', path=...) or request.url_for('static', path=...) . The Jinja2 environment has a global url_for included, which allows us to use url_for inside our templates. We always need to pass the incoming request instance in our context in order to be able to use the url_for function. We can now link to static files from within our HTML templates. For example: < link href = \"{{ url_for('static', path='/css/bootstrap.min.css') }}\" rel = \"stylesheet\" >","title":"Handling templates explicitly"},{"location":"templates/#asynchronous-template-rendering","text":"Jinja2 supports async template rendering, however as a general rule we'd recommend that you keep your templates free from logic that invokes database lookups, or other I/O operations. Instead we'd recommend that you ensure that your views perform all I/O, for example, strictly evaluate any database queries within the view and include the final results in the context.","title":"Asynchronous template rendering"},{"location":"testclient/","text":"The test client allows you to make requests against your ASGI application, using the requests library. from starlette.responses import HTMLResponse from starlette.testclient import TestClient class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'http' self . scope = scope async def __call__ ( self , receive , send ): response = HTMLResponse ( '<html><body>Hello, world!</body></html>' ) await response ( receive , send ) def test_app (): client = TestClient ( App ) response = client . get ( '/' ) assert response . status_code == 200 The test client exposes the same interface as any other requests session. In particular, note that the calls to make a request are just standard function calls, not awaitables. You can use any of requests standard API, such as authentication, session cookies handling, or file uploads. By default the TestClient will raise any exceptions that occur in the application. Occasionally you might want to test the content of 500 error responses, rather than allowing client to raise the server exception. In this case you should use client = TestClient(app, raise_server_exceptions=False) . Testing WebSocket sessions You can also test websocket sessions with the test client. The requests library will be used to build the initial handshake, meaning you can use the same authentication options and other headers between both http and websocket testing. from starlette.testclient import TestClient from starlette.websockets import WebSocket class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'websocket' self . scope = scope async def __call__ ( self , receive , send ): websocket = WebSocket ( self . scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () def test_app (): client = TestClient ( App ) with client . websocket_connect ( '/' ) as websocket : data = websocket . receive_text () assert data == 'Hello, world!' The operations on session are standard function calls, not awaitables. It's important to use the session within a context-managed with block. This ensure that the background thread on which the ASGI application is properly terminated, and that any exceptions that occur within the application are always raised by the test client. Establishing a test session .websocket_connect(url, subprotocols=None, **options) - Takes the same set of arguments as requests.get() . May raise starlette.websockets.Disconnect if the application does not accept the websocket connection. Sending data .send_text(data) - Send the given text to the application. .send_bytes(data) - Send the given bytes to the application. .send_json(data, mode=\"text\") - Send the given data to the application. Use mode=\"binary\" to send JSON over binary data frames. Receiving data .receive_text() - Wait for incoming text sent by the application and return it. .receive_bytes() - Wait for incoming bytestring sent by the application and return it. .receive_json(mode=\"text\") - Wait for incoming json data sent by the application and return it. Use mode=\"binary\" to send JSON over binary data frames. May raise starlette.websockets.Disconnect . Closing the connection .close(code=1000) - Perform a client-side close of the websocket connection.","title":"Test Client"},{"location":"testclient/#testing-websocket-sessions","text":"You can also test websocket sessions with the test client. The requests library will be used to build the initial handshake, meaning you can use the same authentication options and other headers between both http and websocket testing. from starlette.testclient import TestClient from starlette.websockets import WebSocket class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'websocket' self . scope = scope async def __call__ ( self , receive , send ): websocket = WebSocket ( self . scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () def test_app (): client = TestClient ( App ) with client . websocket_connect ( '/' ) as websocket : data = websocket . receive_text () assert data == 'Hello, world!' The operations on session are standard function calls, not awaitables. It's important to use the session within a context-managed with block. This ensure that the background thread on which the ASGI application is properly terminated, and that any exceptions that occur within the application are always raised by the test client.","title":"Testing WebSocket sessions"},{"location":"testclient/#establishing-a-test-session","text":".websocket_connect(url, subprotocols=None, **options) - Takes the same set of arguments as requests.get() . May raise starlette.websockets.Disconnect if the application does not accept the websocket connection.","title":"Establishing a test session"},{"location":"testclient/#sending-data","text":".send_text(data) - Send the given text to the application. .send_bytes(data) - Send the given bytes to the application. .send_json(data, mode=\"text\") - Send the given data to the application. Use mode=\"binary\" to send JSON over binary data frames.","title":"Sending data"},{"location":"testclient/#receiving-data","text":".receive_text() - Wait for incoming text sent by the application and return it. .receive_bytes() - Wait for incoming bytestring sent by the application and return it. .receive_json(mode=\"text\") - Wait for incoming json data sent by the application and return it. Use mode=\"binary\" to send JSON over binary data frames. May raise starlette.websockets.Disconnect .","title":"Receiving data"},{"location":"testclient/#closing-the-connection","text":".close(code=1000) - Perform a client-side close of the websocket connection.","title":"Closing the connection"},{"location":"third-party-packages/","text":"Starlette has a rapidly growing community of developers, building tools that integrate into Starlette, tools that depend on Starlette, etc. Here are some of those third party packages: Plugins Starlette APISpec Link: https://github.com/Woile/starlette-apispec Easy APISpec integration for Starlette. Document your REST API built with Starlette by declaring OpenAPI (Swagger) schemas in YAML format in your endpoints' docstrings. Starlette API Link: https://github.com/PeRDy/starlette-api That library aims to bring a layer on top of Starlette framework to provide useful mechanism for building APIs. It's based on API Star, inheriting some nice ideas like: Schema system based on Marshmallow that allows to declare the inputs and outputs of endpoints and provides a reliable way of validate data against those schemas. Dependency Injection that ease the process of managing parameters needed in endpoints. Components as the base of the plugin ecosystem, allowing you to create custom or use those already defined in your endpoints, injected as parameters. Starlette ASGI objects like Request , Response , Session and so on are defined as components and ready to be injected in your endpoints. webargs-starlette Link: https://github.com/sloria/webargs-starlette Declarative request parsing and validation for Starlette, built on top of webargs . Allows you to parse querystring, JSON, form, headers, and cookies using type annotations. import uvicorn from starlette.applications import Starlette from starlette.responses import JSONResponse from webargs_starlette import use_annotations app = Starlette () @app.route ( \"/\" ) @use_annotations ( locations = ( \"query\" ,)) async def index ( request , name : str = \"World\" ): return JSONResponse ({ \"Hello\" : name }) if __name__ == \"__main__\" : uvicorn . run ( app , port = 5000 ) # curl 'http://localhost:5000/' # {\"Hello\": \"World\"} # curl 'http://localhost:5000/?name=Ada' # {\"Hello\": \"Ada\"} Frameworks Responder Link: https://github.com/kennethreitz/responder A familiar HTTP Service Framework for Python. Flask-style route expression, with new capabilities -- all while using Python 3.6+'s new f-string syntax. Falcon's \"every request and response is passed into to each view and mutated\" methodology. Support for YAML by default. Several of Starlette's optional dependencies pre-installed, like: Production static file server. Uvicorn server. GraphQL support, via Graphene. import responder api = responder . API () @api.route ( \"/{greeting}\" ) async def greet_world ( req , resp , * , greeting ): resp . text = f \"{greeting}, world!\" if __name__ == '__main__' : api . run () FastAPI Link: https://github.com/tiangolo/fastapi High performance, easy to learn, fast to code, ready for production. An API framework inspired by APIStar 's previous server system with type declarations for route parameters, based on the OpenAPI specification version 3.0.0+ (with JSON Schema), powered by Pydantic for the data handling. Use standard Python 3.6+ types as parameters to get: Autocomplete everywhere. Data conversion. Data validation. Automatic documentation with OpenAPI (and JSON Schema), based on the same Python types. Includes: A simple but powerful dependency injection system. Automatic interactive documentation (based on Swagger UI and ReDoc). Security utilities, including OAuth2 with JWT tokens . from fastapi import FastAPI app = FastAPI () @app.get ( '/' ) def read_root (): return { 'hello' : 'world' }","title":"Third Party Packages"},{"location":"third-party-packages/#plugins","text":"","title":"Plugins"},{"location":"third-party-packages/#starlette-apispec","text":"Link: https://github.com/Woile/starlette-apispec Easy APISpec integration for Starlette. Document your REST API built with Starlette by declaring OpenAPI (Swagger) schemas in YAML format in your endpoints' docstrings.","title":"Starlette APISpec"},{"location":"third-party-packages/#starlette-api","text":"Link: https://github.com/PeRDy/starlette-api That library aims to bring a layer on top of Starlette framework to provide useful mechanism for building APIs. It's based on API Star, inheriting some nice ideas like: Schema system based on Marshmallow that allows to declare the inputs and outputs of endpoints and provides a reliable way of validate data against those schemas. Dependency Injection that ease the process of managing parameters needed in endpoints. Components as the base of the plugin ecosystem, allowing you to create custom or use those already defined in your endpoints, injected as parameters. Starlette ASGI objects like Request , Response , Session and so on are defined as components and ready to be injected in your endpoints.","title":"Starlette API"},{"location":"third-party-packages/#webargs-starlette","text":"Link: https://github.com/sloria/webargs-starlette Declarative request parsing and validation for Starlette, built on top of webargs . Allows you to parse querystring, JSON, form, headers, and cookies using type annotations. import uvicorn from starlette.applications import Starlette from starlette.responses import JSONResponse from webargs_starlette import use_annotations app = Starlette () @app.route ( \"/\" ) @use_annotations ( locations = ( \"query\" ,)) async def index ( request , name : str = \"World\" ): return JSONResponse ({ \"Hello\" : name }) if __name__ == \"__main__\" : uvicorn . run ( app , port = 5000 ) # curl 'http://localhost:5000/' # {\"Hello\": \"World\"} # curl 'http://localhost:5000/?name=Ada' # {\"Hello\": \"Ada\"}","title":"webargs-starlette"},{"location":"third-party-packages/#frameworks","text":"","title":"Frameworks"},{"location":"third-party-packages/#responder","text":"Link: https://github.com/kennethreitz/responder A familiar HTTP Service Framework for Python. Flask-style route expression, with new capabilities -- all while using Python 3.6+'s new f-string syntax. Falcon's \"every request and response is passed into to each view and mutated\" methodology. Support for YAML by default. Several of Starlette's optional dependencies pre-installed, like: Production static file server. Uvicorn server. GraphQL support, via Graphene. import responder api = responder . API () @api.route ( \"/{greeting}\" ) async def greet_world ( req , resp , * , greeting ): resp . text = f \"{greeting}, world!\" if __name__ == '__main__' : api . run ()","title":"Responder"},{"location":"third-party-packages/#fastapi","text":"Link: https://github.com/tiangolo/fastapi High performance, easy to learn, fast to code, ready for production. An API framework inspired by APIStar 's previous server system with type declarations for route parameters, based on the OpenAPI specification version 3.0.0+ (with JSON Schema), powered by Pydantic for the data handling. Use standard Python 3.6+ types as parameters to get: Autocomplete everywhere. Data conversion. Data validation. Automatic documentation with OpenAPI (and JSON Schema), based on the same Python types. Includes: A simple but powerful dependency injection system. Automatic interactive documentation (based on Swagger UI and ReDoc). Security utilities, including OAuth2 with JWT tokens . from fastapi import FastAPI app = FastAPI () @app.get ( '/' ) def read_root (): return { 'hello' : 'world' }","title":"FastAPI"},{"location":"websockets/","text":"Starlette includes a WebSocket class that fulfils a similar role to the HTTP request, but that allows sending and receiving data on a websocket. WebSocket Signature: WebSocket(scope, receive=None, send=None) from starlette.websockets import WebSocket class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'websocket' self . scope = scope async def __call__ ( self , receive , send ): websocket = WebSocket ( self . scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () WebSockets present a mapping interface, so you can use them in the same way as a scope . For instance: websocket['path'] will return the ASGI path. URL The websocket URL is accessed as websocket.url . The property is actually a subclass of str , and also exposes all the components that can be parsed out of the URL. For example: websocket.url.path , websocket.url.port , websocket.url.scheme . Headers Headers are exposed as an immutable, case-insensitive, multi-dict. For example: websocket.headers['sec-websocket-version'] Query Parameters Headers are exposed as an immutable multi-dict. For example: websocket.query_params['search'] Path Parameters Router path parameters are exposed as a dictionary interface. For example: request.path_params['username'] Accepting the connection await websocket.accept(subprotocol=None) Sending data await websocket.send_text(data) await websocket.send_bytes(data) await websocket.send_json(data) JSON messages default to being sent over text data frames, from version 0.10.0 onwards. Use websocket.send_json(data, mode=\"binary\") to send JSON over binary data frames. Receiving data await websocket.receive_text() await websocket.receive_bytes() await websocket.receive_json() May raise starlette.websockets.Disconnect() . JSON messages default to being received over text data frames, from version 0.10.0 onwards. Use websocket.receive_json(data, mode=\"binary\") to receive JSON over binary data frames. Closing the connection await websocket.close(code=1000) Sending and receiving messages If you need to send or receive raw ASGI messages then you should use websocket.send() and websocket.receive() rather than using the raw send and receive callables. This will ensure that the websocket's state is kept correctly updated. await websocket.send(message) await websocket.receive()","title":"WebSockets"},{"location":"websockets/#websocket","text":"Signature: WebSocket(scope, receive=None, send=None) from starlette.websockets import WebSocket class App : def __init__ ( self , scope ): assert scope [ 'type' ] == 'websocket' self . scope = scope async def __call__ ( self , receive , send ): websocket = WebSocket ( self . scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () WebSockets present a mapping interface, so you can use them in the same way as a scope . For instance: websocket['path'] will return the ASGI path.","title":"WebSocket"},{"location":"websockets/#url","text":"The websocket URL is accessed as websocket.url . The property is actually a subclass of str , and also exposes all the components that can be parsed out of the URL. For example: websocket.url.path , websocket.url.port , websocket.url.scheme .","title":"URL"},{"location":"websockets/#headers","text":"Headers are exposed as an immutable, case-insensitive, multi-dict. For example: websocket.headers['sec-websocket-version']","title":"Headers"},{"location":"websockets/#query-parameters","text":"Headers are exposed as an immutable multi-dict. For example: websocket.query_params['search']","title":"Query Parameters"},{"location":"websockets/#path-parameters","text":"Router path parameters are exposed as a dictionary interface. For example: request.path_params['username']","title":"Path Parameters"},{"location":"websockets/#accepting-the-connection","text":"await websocket.accept(subprotocol=None)","title":"Accepting the connection"},{"location":"websockets/#sending-data","text":"await websocket.send_text(data) await websocket.send_bytes(data) await websocket.send_json(data) JSON messages default to being sent over text data frames, from version 0.10.0 onwards. Use websocket.send_json(data, mode=\"binary\") to send JSON over binary data frames.","title":"Sending data"},{"location":"websockets/#receiving-data","text":"await websocket.receive_text() await websocket.receive_bytes() await websocket.receive_json() May raise starlette.websockets.Disconnect() . JSON messages default to being received over text data frames, from version 0.10.0 onwards. Use websocket.receive_json(data, mode=\"binary\") to receive JSON over binary data frames.","title":"Receiving data"},{"location":"websockets/#closing-the-connection","text":"await websocket.close(code=1000)","title":"Closing the connection"},{"location":"websockets/#sending-and-receiving-messages","text":"If you need to send or receive raw ASGI messages then you should use websocket.send() and websocket.receive() rather than using the raw send and receive callables. This will ensure that the websocket's state is kept correctly updated. await websocket.send(message) await websocket.receive()","title":"Sending and receiving messages"}]}